[["index.html", "RNA-seq-analysis RNA-seq analysis workshop", " RNA-seq-analysis RNA-seq analysis workshop The published version for this module can be found on my bookdown site RNA-seq-analysis. "],["differential-gene-expression-dge-analysis-overview.html", "Chapter 1 Differential gene expression (DGE) analysis overview 1.1 Review of the dataset 1.2 Setting up 1.3 Differential gene expression analysis overview", " Chapter 1 Differential gene expression (DGE) analysis overview The goal of RNA-seq is to perform differential expression testing to determine which genes are expressed at different levels between conditions. These genes can offer biological insight into the processes affected by the condition(s) of interest. To determine the expression levels of genes, our RNA-seq workflow follows the steps detailed in the image below inside the box. All steps are performed on the command line (Linux/Unix) through the generation of read counts per gene as discussed in Corey’s lectures. The differential expression analysis and any downstream functional analysis are generally performed in R using R packages specifically designed for the complex statistical analyses required to determine whether genes are differentially expressed starting from the count matrices. Alt text In the next few lessons, we will walk you through an end-to-end gene-level RNA-seq differential expression workflow using various R packages. We will start with the count matrix, perform exploratory data analysis for quality assessment and to explore the relationship between samples, perform differential expression analysis, and visually explore the results prior to performing downstream functional analysis. 1.1 Review of the dataset We will be using the full count matrix from the RNA-seq dataset that is part of a larger study described in Kenny PJ et al, Cell Rep 2014 investigating the interactions between genes potentially involved in Fragile X syndrome (FXS). FXS is a genetic disorder and the leading cause of inherited intellectual disabilities like autism. FXS is caused by aberrant production of a protein called Fragile X Messenger Ribonucleoprotein (FMRP) that is needed for brain development. People who have FXS do not make this protein. The authors demonstrated that FMRP associates with another RNA-binding protein MOV10 (Mov10 RISC Complex RNA Helicase) and acts to regulate the translation of a subset of RNAs. What is the function of FMRP and MOV10? FMRP is “most commonly found in the brain, is essential for normal cognitive development and female reproductive function. Mutations of this gene can lead to fragile X syndrome, mental retardation, premature ovarian failure, autism, Parkinson’s disease, developmental delays and other cognitive deficits.” - from wikipedia MOV10 is a putative RNA helicase that is associated with FMRP in the context of the microRNA pathway. MOV10 has a role in regulating translation: it facilitates microRNA-mediated translation of some RNAs, but it also increases expression of other RNAs. The aim of the RNAseq part of the study was to characterize the transcription expression patterns of FMRP and MOV10 to identify overlapping target genes which would suggest that these genes are regulated by the MOV10-FMRP complex. Alt text Model for MOV10-FMRP** Association in Translation Regulation. Top: fate of RNAs bound by MOV10. MOV10** binds the 3′ UTR-encoded G-rich structure to reveal MREs for subsequent AGO2 association. Middle: fate of RNAs bound by FMRP. FMRP binds RNAs in the nucleus. Upon export, FMRP recruits MOV10, which ultimately unwinds MREs for association with AGO2. Bottom: FMRP recruits MOV10 to RNAs; however, binding of both FMRP and MOV10 in proximity of MRE blocks association with AGO2. Red line indicates MRE. RNA-seq was performed on HEK293F cells that were either transfected with a MOV10 transgene, or siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below. Alt text Using these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition. Links to raw data [GEO]: https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE51443 “Gene Expression Omnibus” [SRA]: https://trace.ncbi.nlm.nih.gov/Traces/sra/?study=SRP031507 “Sequence Read Archive” Our questions: * What patterns of expression can we identify with the loss or gain of MOV10? * Are there any genes shared between the two conditions? 1.2 Setting up Go to the File menu and open 09-DGE_codebook.Rmd. This should open up a script editor in the top left hand corner. This is where we will be running all commands required for this analysis. Your working directory should have these folders: data, meta and results: setup 1.2.1 Loading libraries For this analysis we will be using several R packages, some which have been installed from CRAN and others from Bioconductor. To use these packages (and the functions contained within them), we need to load the libraries. Add the following to your script and don’t forget to comment liberally! ## Setup ### Bioconductor and CRAN libraries used library(tidyverse) library(RColorBrewer) library(DESeq2) library(pheatmap) 1.2.2 Loading data To load the data into our current environment, we will be using the read.table function. We need to provide the path to each file and also specify arguments to let R know that we have a header (header = T) and the first column is our row names (row.names =1). By default the function expects tab-delimited files, which is what we have. ## Load in data data &lt;- read.table(&quot;data/Mov10_full_counts.txt&quot;, header=T, row.names=1) meta &lt;- read.table(&quot;meta/Mov10_full_meta.txt&quot;, header=T, row.names=1) Use class() to inspect our data and make sure we are working with data frames: ### Check classes of the data we just brought in class(meta) class(data) 1.2.3 Viewing data Make sure your datasets contain the expected samples / information before proceeding to perfom any type of analysis. View(meta) View(data) 1.3 Differential gene expression analysis overview So what does this count data actually represent? The count data used for differential expression analysis represents the number of sequence reads that originated from a particular gene. The higher the number of counts, the more reads associated with that gene, and the assumption that there was a higher level of expression of that gene in the sample. Alt text With differential expression analysis, we are looking for genes that change in expression between two or more groups (defined in the metadata) - case vs. control - correlation of expression with some variable or clinical outcome Why does it not work to identify differentially expressed gene by ranking the genes by how different they are between the two groups (based on fold change values)? Alt text More often than not, there is much more going on with your data than what you are anticipating. Genes that vary in expression level between samples is a consequence of not only the experimental variables of interest but also due to extraneous sources. The goal of differential expression analysis to determine the relative role of these effects, and to separate the “interesting” from the “uninteresting”. Alt text The “uninteresting” presents as sources of variation in your data, and so even though the mean expression levels between sample groups may appear to be quite different, it is possible that the difference is not actually significant. This is illustrated for ‘GeneA’ expression between ‘untreated’ and ‘treated’ groups in the figure below. The mean expression level of geneA for the ‘treated’ group is twice as large as for the ‘untreated’ group, but the variation between replicates indicates that this may not be a significant difference. We need to take into account the variation in the data (and where it might be coming from) when determining whether genes are differentially expressed. Alt text The goal of differential expression analysis is to determine, for each gene, whether the differences in expression (counts) between groups is significant given the amount of variation observed within groups (replicates). To test for significance, we need an appropriate statistical model that accurately performs normalization (to account for differences in sequencing depth, etc.) and variance modeling (to account for few numbers of replicates and large dynamic expression range). 1.3.1 RNA-seq count distribution To determine the appropriate statistical model, we need information about the distribution of counts. To get an idea about how RNA-seq counts are distributed, let’s plot the counts for a single sample, ‘Mov10_oe_1’: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) Alt text If we zoom in close to zero, we can see a large number of genes with counts of zero: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlim(-5, 500) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) Alt text These images illustrate some common features of RNA-seq count data, including a low number of counts associated with a large proportion of genes, and a long right tail due to the lack of any upper limit for expression. 1.3.2 Modeling count data Count data is often modeled using the binomial distribution. The Binomial distribution is a common probability distribution that models the probability of obtaining one of two outcomes under a given number of parameters. It summarizes the number of trials when each trial has the same chance of attaining one specific outcome. For example, it can give you the probability of getting a number of heads upon tossing a coin a number of times. However, not all count data can be fit with the binomial distribution. The binomial is based on discrete events and used in situations when you have a certain number of cases. When the number of cases is very large (i.e. people who buy lottery tickets), but the probability of an event is very small (probability of winning), the Poisson distribution is used to model these types of count data. Alt text With RNA-seq data, for each sample we have millions of reads being sequenced and the probability of a read mapping to a gene is extremely low. Thus, it would be an appropriate situation to use the Poisson distribution. However, a unique property of this distribution is that the mean == variance given by the single parameter \\(\\lambda\\). For us to apply a poisson distribution to our data, we first need to find out whether our data fulfills the criteria to use the poisson distribution. To do that we can plot the mean versus variance for the ‘Mov10 overexpression’ replicates: # apply applies a function to the margins of a matrix # apply(X, MARGIN, FUN) # where X is a matrix # to apply a function to each row of a matrix, use MARGIN = 1 # to apply a function to each column of a matrix, use MARGIN = 2 # FUN can be any function that takes a vector as input and returns a single value mean_counts &lt;- apply(data[, 3:5], 1, mean) variance_counts &lt;- apply(data[, 3:5], 1, var) # for ggplot we need the data to be in a data.frame df &lt;- data.frame(mean_counts, variance_counts) ggplot(df) + geom_point(aes(x=mean_counts, y=variance_counts)) + geom_line(aes(x=mean_counts, y=mean_counts, color=&quot;red&quot;)) + scale_y_log10() + scale_x_log10() Alt text By plotting the mean versus the variance of our data we can easily see that the mean &lt; variance and therefore it does not fit the Poisson distribution. Genes having higher mean counts have even higher variance. Also for gene having low mean counts, there is a scatter of points and we can see that there is variability even in the variance. To account for this extra variance we need a new model. The model that fits best, given this type of variability between replicates, is the Negative Binomial (NB) model. Essentially, the NB model is a good approximation for data where the mean &lt; variance, as is the case with RNA-seq count data. 1.3.3 Improving mean estimates (i.e. reducing variance) with biological replicates The variance or scatter tends to reduce as we increase the number of biological replicates (the distribution will approach the Poisson distribution with increasing numbers of replicates). The value of additional replicates is that as you add more data (replicates), you get increasingly precise estimates of group means, and ultimately greater confidence in the ability to distinguish differences between sample classes (i.e. more DE genes). The figure below illustrates the relationship between sequencing depth and number of replicates on the number of differentially expressed genes identified [1]. Note that an increase in the number of replicates tends to return more DE genes than increasing the sequencing depth. This is because most of the biological variability is between samples. Therefore, generally more replicates are better than higher sequencing depth, with the caveat that higher depth is required for detection of lowly expressed DE genes and for performing isoform-level differential expression. Generally, the minimum sequencing depth recommended is 20-30 million reads per sample, but we have seen good RNA-seq experiments with 10 million reads if there are a good number of replicates. Alt text NOTE Biological replicates represent multiple samples (i.e. RNA from different mice) representing the same sample class Technical replicates represent the same sample (i.e. RNA from the same mouse) but with technical steps replicated Usually biological variance is much greater than technical variance, so we do not need to account for technical variance to identify biological differences in expression Don’t spend money on technical replicates - biological replicates are much more useful NOTE: If you are using cell lines and are unsure whether or not you have prepared biological or technical replicates, take a look at this link. This is a useful resource in helping you determine how best to set up your in-vitro experiment. 1.3.4 Differential expression analysis workflow To model counts appropriately when performing a differential expression analysis, there are a number of software packages that have been developed for differential expression analysis of RNA-seq data. Even as new methods are continuously being developed a few tools are generally recommended as best practice, e.g. DESeq2 and EdgeR. Both these tools use the negative binomial model, employ similar methods, and typically, yield similar results. They are pretty stringent, and have a good balance between sensitivity and specificity (reducing both false positives and false negatives). Here is a comparison of the three most highy used software packages for differential expression analysis. No single method is optimal under all circumstances, for example, limma works best when sample number is high, and edgeR and DESeq2 perform well for small sample sizes. It is also difficult to compare analysis methods due to different procedures in calculating pvalues. We will be using DESeq2 for the DE analysis, and the analysis steps with DESeq2 are shown in the flowchart below. DESeq2 first normalizes the count data to account for differences in library sizes and RNA composition between samples. Then, we will use the normalized counts to make some plots for QC at the gene and sample level. The final step is to use the appropriate functions from the DESeq2 package to perform the differential expression analysis. Alt text We will go in-depth into each of these steps in the following lessons, but additional details and helpful suggestions regarding DESeq2 can be found in the DESeq2 vignette. As you go through this workflow and questions arise, you can reference the vignette from within RStudio: vignette(&quot;DESeq2&quot;) This is very convenient, as it provides a wealth of information at your fingertips! Be sure to use this as you need during the workshop. This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited. "],["count-normalization.html", "Chapter 2 Count normalization 2.1 Normalization 2.2 Geometric Mean 2.3 Count normalization of Mov10 dataset", " Chapter 2 Count normalization 2.1 Normalization The first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples. Alt text The counts of mapped reads for each gene is proportional to the expression of RNA (“interesting”) in addition to many other factors (“uninteresting”). Normalization is the process of scaling raw count values to account for the “uninteresting” factors. In this way the expression levels are more comparable between and/or within samples. The main factors often considered during normalization are: Sequencing depth: Accounting for sequencing depth is necessary for comparison of gene expression between samples. In the example below, each gene appears to have doubled in expression in Sample A relative to Sample B, however this is a consequence of Sample A having double the sequencing depth. Alt text NOTE: In the figure above, each pink and green rectangle represents a read aligned to a gene. Reads connected by dashed lines connect a read spanning an intron. Gene length: Accounting for gene length is necessary for comparing expression between different genes within the same sample. In the example, Gene X and Gene Y have similar levels of expression, but the number of reads mapped to Gene X would be many more than the number mapped to Gene Y because Gene X is longer. Alt text RNA composition: A few highly differentially expressed genes between samples, differences in the number of genes expressed between samples, or presence of contamination can skew some types of normalization methods. Accounting for RNA composition is recommended for accurate comparison of expression between samples, and is particularly important when performing differential expression analyses [1]. In the example, if we were to divide each sample by the total number of counts to normalize, the counts would be greatly skewed by the DE gene, which takes up most of the counts for Sample A, but not Sample B. Most other genes for Sample A would be divided by the larger number of total counts and appear to be less expressed than those same genes in Sample B. While normalization is essential for differential expression analyses, it is also necessary for exploratory data analysis, visualization of data, and whenever you are exploring or comparing counts between or within samples. 2.1.1 Common normalization methods Several common normalization methods exist to account for these differences: Normalization method Description Accounted factors Recommendations for use TPM (transcripts per kilobase million) counts per length of transcript (kb) per million reads mapped sequencing depth and gene length gene count comparisons within a sample or between samples of the same sample group; NOT for DE analysis RPKM/FPKM (reads/fragments per kilobase of exon per million reads/fragments mapped) similar to TPM sequencing depth and gene length gene count comparisons between genes within a sample; NOT for between sample comparisons or DE analysis DESeq2’s median of ratios [1] counts divided by sample-specific size factors determined by median ratio of gene counts relative to geometric mean per gene sequencing depth and RNA composition gene count comparisons between samples and for DE analysis; NOT for within sample comparisons EdgeR’s trimmed mean of M values (TMM) [2] uses a weighted trimmed mean of the log expression ratios between samples sequencing depth, RNA composition gene count comparisons between samples and for DE analysis; NOT for within sample comparisons 2.1.2 RPKM/FPKM (not recommended) While TPM and RPKM/FPKM normalization methods both account for sequencing depth and gene length, RPKM/FPKM are not recommended. The reason is that the normalized count values output by the RPKM/FPKM method are not comparable between samples. Using RPKM/FPKM normalization, the total number of RPKM/FPKM normalized counts for each sample will be different. Therefore, you cannot compare the normalized counts for each gene equally between samples. RPKM-normalized counts table gene sampleA sampleB XCR1 5.5 5.5 WASHC1 73.4 21.8 … … … Total RPKM-normalized counts 1,000,000 1,500,000 For example, in the table above, SampleA has a greater proportion of counts associated with XCR1 (5.5/1,000,000) than does sampleB (5.5/1,500,000) even though the RPKM count values are the same. Therefore, we cannot directly compare the counts for XCR1 (or any other gene) between sampleA and sampleB because the total number of normalized counts are different between samples. 2.1.3 DESeq2-normalized counts: Median of ratios method Since tools for differential expression analysis are comparing the counts between sample groups for the same gene, gene length does not need to be accounted for by the tool. However, sequencing depth and RNA composition do need to be taken into account. To normalize for sequencing depth and RNA composition, DESeq2 uses the median of ratios method. On the user-end there is only one step, but on the back-end there are multiple steps involved, as described below. NOTE: The steps below describe in detail some of the steps performed by DESeq2 when you run a single function to get DE genes. Basically, for a typical RNA-seq analysis, you would not run these steps individually. Step 1: creates a pseudo-reference sample (row-wise geometric mean) 2.2 Geometric Mean The geometric mean of a set of \\(n\\) positive numbers \\(x_1, x_2, \\dots, x_n\\) is defined as the \\(n\\)th root of the product of the numbers. It is mathematically expressed as: \\[ \\text{Geometric Mean} = \\left( \\prod_{i=1}^{n} x_i \\right)^{\\frac{1}{n}} \\] where: - \\(x_1, x_2, \\dots, x_n\\) are the individual numbers in the set, - \\(\\prod_{i=1}^{n} x_i\\) denotes the product of all the numbers. For each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples. The geometric mean is less affected by extremely high or low values than the arithmetic mean, making it more appropriate for skewed data, such as count data that has a large number of genes with low counts. gene sampleA sampleB pseudo-reference sample EF2A 1489 906 sqrt(1489 * 906) = 1161.5 ABCD1 22 13 sqrt(22 * 13) = 17.7 … … … … Step 2: calculates ratio of each sample to the reference For every gene in a sample, the ratios (sample/ref) are calculated (as shown below). This is performed for each sample in the dataset. Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample. gene sampleA sampleB pseudo-reference sample ratio of sampleA/ref ratio of sampleB/ref EF2A 1489 906 1161.5 1489/1161.5 = 1.28 906/1161.5 = 0.78 ABCD1 22 13 16.9 22/16.9 = 1.30 13/16.9 = 0.77 MEFV 793 410 570.2 793/570.2 = 1.39 410/570.2 = 0.72 BAG1 76 42 56.5 76/56.5 = 1.35 42/56.5 = 0.74 MOV10 521 1196 883.7 521/883.7 = 0.590 1196/883.7 = 1.35 … … … … Step 3: calculate the normalization factor for each sample (size factor) The median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value: normalization_factor_sampleA &lt;- median(c(1.28, 1.3, 1.39, 1.35, 0.59)) normalization_factor_sampleB &lt;- median(c(0.78, 0.77, 0.72, 0.74, 1.35)) The figure below illustrates the median value for the distribution of all gene ratios for a single sample (frequency is on the y-axis). Alt text The median of ratios method makes the assumption that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not represent the median ratio values). This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes. Usually these size factors are around 1, if you see large variations between samples it is important to take note since it might indicate the presence of extreme outliers. Step 4: calculate the normalized count values using the normalization factor This is performed by dividing each raw count value in a given sample by that sample’s normalization factor to generate normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for SampleA was 1.3 and the median ratio for SampleB was 0.77, you could calculate normalized counts as follows: SampleA median ratio = 1.3 SampleB median ratio = 0.77 Raw Counts gene sampleA sampleB EF2A 1489 906 ABCD1 22 13 … … … Normalized Counts gene sampleA sampleB EF2A 1489 / 1.3 = 1145.39 906 / 0.77 = 1176.62 ABCD1 22 / 1.3 = 16.92 13 / 0.77 = 16.88 … … … Please note that normalized count values are not whole numbers. Exercise Determine the normalized counts for your gene of interest, PD1, given the raw counts and size factors below. NOTE: You will need to run the code below to generate the raw counts dataframe (PD1) and the size factor vector (size_factors), then use these objects to determine the normalized counts values: # Raw counts for PD1 PD1 &lt;- c(21, 58, 17, 97, 83, 10) names(PD1) &lt;- paste0(&quot;Sample&quot;, 1:6) PD1 &lt;- data.frame(PD1) PD1 &lt;- t(PD1) # Size factors for each sample size_factors &lt;- c(1.32, 0.70, 1.04, 1.27, 1.11, 0.85) 2.3 Count normalization of Mov10 dataset Now that we know the theory of count normalization, we will normalize the counts for the Mov10 dataset using DESeq2. This requires a few steps: Ensure the row names of the metadata dataframe are present and in the same order as the column names of the counts dataframe. Create a DESeqDataSet object Generate the normalized counts 2.3.1 1. Match the metadata and counts data We should always make sure that we have sample names that match between the two files, and that the samples are in the right order. DESeq2 will output an error if this is not the case. ### Check that sample names match in both files all(colnames(data) %in% rownames(meta)) all(colnames(data) == rownames(meta)) The colnames of our data don’t match the rownames of our metadata so we need to reorder them. We can use the match function: # write the code to match the colnames of data to the rownames of meta # check that the rownames of the metadata match the colnames of the data 2.3.2 2. Create DESEq2 object Bioconductor software packages often define and use a custom class within R for storing data (input data, intermediate data and also result data). These custom data structures are similar to lists in that they can contain multiple different data types/structures within them. But, unlike lists they have pre-specified data slots, which hold specific types/classes of data. The data stored in these pre-specified slots can be accessed by using specific package-defined functions. Let’s start by creating the DESeqDataSet object and then we can talk a bit more about what is stored inside it. To create the object we will need the count matrix and the metadata table as input. We will also need to specify a design formula. The design formula specifies the column(s) in the metadata table and how they should be used in the analysis. For our dataset we only have one column we are interested in, that is ~sampletype. This column has three factor levels, which tells DESeq2 that for each gene we want to evaluate gene expression change with respect to these different levels. ## Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype) deseq1 You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use counts(): head(counts(dds[,1:5])) As we go through the workflow we will use the relevant functions to check what information gets stored inside our object. We can also run: slotNames(dds) 2.3.3 3. Generate the Mov10 normalized counts The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. Alt text To perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. dds &lt;- estimateSizeFactors(dds) By assigning the results back to the dds object we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factor applied to each sample using: sizeFactors(dds) Now, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized=TRUE) We can save this normalized data matrix to file for later use: write.table(normalized_counts, file=&quot;data/normalized_counts.txt&quot;, sep=&quot;\\t&quot;, quote=F, col.names=NA) "],["quality-control.html", "Chapter 3 Quality Control 3.1 Sample-level QC 3.2 Gene-level QC 3.3 Mov10 quality assessment and exploratory analysis using DESeq2", " Chapter 3 Quality Control The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level steps to perform QC checks on the count data to help us ensure that the samples/replicates look good. Alt text 3.1 Sample-level QC A useful initial step in an RNA-seq analysis is often to assess overall similarity between samples: Which samples are similar to each other, which are different? Does this fit to the expectation from the experiment’s design? What are the major sources of variation in the dataset? To explore the similarity of our samples, we will be performing sample-level QC using Principal Component Analysis (PCA) and hierarchical clustering methods. Our sample-level QC allows us to see how well our replicates cluster together, as well as, observe whether our experimental condition represents the major source of variation in the data. Performing sample-level QC can also identify any sample outliers, which may need to be explored further to determine whether they need to be removed prior to DE analysis. Alt text When using these unsupervised clustering methods, log2-transformation of the normalized counts improves the distances/clustering for visualization. DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. Alt text 3.1.1 Principal Component Analysis (PCA) Principal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). Details regarding PCA are given below, and if you would like a more thorough description, we encourage you to explore StatQuest’s video. Suppose we had a dataset with two samples and four genes. Based on this expression data we want to evaluate the relationship between these samples. We could plot the counts of one sample versus another, with Sample 1 on the x-axis and Sample 2 on the y-axis as shown below: Alt text For PCA analysis, the first step is taking this plot and drawing a line through the data in the direction representing the most variation. In this example, the most variation is along the diagonal. That is, the largest spread in the data is between the two endpoints of this line. This is called the first principal component, or PC1. The genes at the endpoints of this line (Gene B and Gene C) have the greatest influence on the direction of this line. Alt text After drawing this line and establishing the amount of influence per gene, PCA will compute a per sample score. The per sample PC1 score is computed by taking the product of the influence and the normalized read count and summing across all genes. We could draw another line through the data representing the second most amount of variation in the data (PC2) and compute scores, followed by a third line and so on until you hit the total number of samples in your dataset. Sample1 PC1 score = (read count Gene A * influence Gene A) + (read count Gene B * influence Gene B) + .. for all genes Calculating the influence of each gene is a bit complicated, but to give you an idea,the first step is to calculate a z-score for each gene: Alt text The z-score is a measure of variability. So it’s easy to see how in our plot, the influence of the two endpoints will be greater than the other points because their z-scores are greater as they are farther away from the mean and therefore they will have a greater influence on PC1. Alt text The take home message for our purposes is that if two samples have similar levels of expression for the genes that contribute significantly to the variation represented by PC1, they will be plotted close together on the PC1 axis. Therefore, we would expect biological replicates to have similar scores (since the same genes are changing) and cluster together on PC1 and/or PC2, and the samples from different treatment groups to have different scores. This is easiest to understand by visualizing example PCA plots. 3.1.1.1 Interpreting PCA plots We have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment. To evaluate the results of a PCA, we usually plot principal components against each other, starting with PCs that explain the most amount of variation in your data. In reality, your dataset will have larger dimensions (more samples, and many, many more genes). The initial sample-to-sample plot, will therefore be in n-dimensional space with n axes representing the total number of samples you have. The end result is a 2-dimensional matrix with rows representing samples and columns reflecting scores for each of the principal components. To evaluate the results of a PCA, we usually plot principal components against each other, starting with PCs that explain the most amount of variation in your data. If two samples have similar levels of expression for the genes that contribute significantly to the variation represented by PC1, they will be plotted close together on the PC1 axis. Therefore, we would expect biological replicates to have similar scores (since the same genes are changing) and cluster together on PC1 and/or PC2, and the samples from different treatment groups to have different scores. This is easiest to understand by visualizing example PCA plots.** 3.1.1.2 Interpreting PCA plots example We have an example dataset and a few associated PCA plots below to get a feel for how to interpret them. The metadata for the experiment is displayed below. The main condition of interest is treatment. Alt text When visualizing on PC1 and PC2, we don’t see the samples separate by treatment, so we decide to explore other sources of variation present in the data. We hope that we have included all possible known sources of variation in our metadata table, and we can use these factors to color the PCA plot. Alt text We start with the factor cage, but the cage factor does not seem to explain the variation on PC1 or PC2. Alt text Then, we color by the sex factor, which appears to separate samples on PC2. This is good information to take note of, as we can use it downstream to account for the variation due to sex in the model and regress it out. Alt text Next we explore the strain factor and find that it explains the variation on PC1. Alt text It’s great that we have been able to identify the sources of variation for both PC1 and PC2. By accounting for it in our model, we should be able to detect more genes differentially expressed due to treatment. Worrisome about this plot is that we see two samples that do not cluster with the correct strain. This would indicate a likely sample swap and should be investigated to determine whether these samples are indeed the labeled strains. If we found there was a switch, we could swap the samples in the metadata. However, if we think they are labeled correctly or are unsure, we could just remove the samples from the dataset. Still we haven’t found if treatment is a major source of variation after strain and sex. So, we explore PC3 and PC4 to see if treatment is driving the variation represented by either of these PCs. Alt text We find that the samples separate by treatment on PC3, and are optimistic about our DE analysis since our condition of interest, treatment, is separating on PC3 and we can regress out the variation driving PC1 and PC2. Exercise The figure below was generated from a time course experiment with sample groups ‘Ctrl’ and ‘Sci’ and the following timepoints: 0h, 2h, 8h, and 16h. Determine the sources explaining the variation represented by PC1 and PC2. Do the sample groups separate well? Do the replicates cluster together for each sample group? Are there any outliers in the data? Should we have any other concerns regarding the samples in the dataset? Alt text 3.1.2 Hierarchical Clustering Heatmap Similar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot. In the plot below, we would be quite concerned about ‘Wt_3’ and ‘KD_3’ samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples. Alt text 3.2 Gene-level QC In addition to examining how well the samples/replicates cluster together, there are a few more QC steps. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. The genes omitted fall into three categories: Genes with zero counts in all samples Genes with an extreme count outlier Genes with a low mean normalized counts Alt text DESeq2 will perform this filtering by default; however other DE tools, such as EdgeR will not. Filtering is a necessary step, especially when you are using methods other than DESeq2. 3.3 Mov10 quality assessment and exploratory analysis using DESeq2 Now that we have a good understanding of the QC steps normally employed for RNA-seq, let’s implement them for the Mov10 dataset we are going to be working with. 3.3.1 Transform normalized counts using the rlog transformation To improve the distances/clustering for the PCA and heirarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts. The rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these tranformed counts downstream. ### Transform counts for data visualization rld &lt;- rlog(dds, blind=TRUE) The blind=TRUE argument results in a transformation unbiased to sample condition information. When performing quality assessment, it is important to include this option. The DESeq2 vignette has more details. The rlog function returns a DESeqTransform object, another type of DESeq-specific object. The reason you don’t just get a matrix of transformed values is because all of the parameters (i.e. size factors) that went into computing the rlog transform are stored in that object. We use this object to plot the PCA and heirarchical clustering figures for quality assessment. 3.3.2 Principal components analysis (PCA) DESeq2 has a built-in function for plotting PCA plots, that uses ggplot2 under the hood. This is great because it saves us having to type out lines of code and having to fiddle with the different ggplot2 layers. In addition, it takes the rlog object as an input directly, hence saving us the trouble of extracting the relevant information from it. The function plotPCA() requires two arguments as input: an rlog object and the intgroup (the column in our metadata that we are interested in). ### Plot PCA plotPCA(rld, intgroup=&quot;sampletype&quot;) pca What does this plot tell you about the similarity of samples? Does it fit the expectation from the experimental design? By default the function uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. Resources are available to learn how to do more complex inquiries using the PCs. 3.3.3 Hierarchical Clustering Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: ### Extract the rlog matrix from the object rld_mat &lt;- assay(rld) ## assay() is function from the &quot;SummarizedExperiment&quot; package that was loaded when you loaded DESeq2 Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: ### Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) ## cor() is a base R function head(rld_cor) ## check the output of cor(), make note of the rownames and colnames And now to plot the correlation values as a heatmap: ### Plot heatmap pheatmap(rld_cor) heatmap1 Overall, we observe pretty high correlations across the board ( &gt; 0.999) suggesting no outlying sample(s). Also, similar to the PCA plot you see the samples clustering together by sample group. Together, these plots suggest to us that the data are of good quality and we have the green light to proceed to differential expression analysis. NOTE: The pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot. heat.colors &lt;- brewer.pal(6, &quot;Blues&quot;) pheatmap(rld_cor, color = heat.colors, border_color=NA, fontsize = 10, fontsize_row = 10, height=20) Curious on all of the available color palettes offered by the RColorBrewer package? Try typing in your console display.brewer.all() and see what happens! This lesson has been developed by members of the teaching team at the Harvard Chan Bioinformatics Core (HBC). These are open access materials distributed under the terms of the Creative Commons Attribution license (CC BY 4.0), which permits unrestricted use, distribution, and reproduction in any medium, provided the original author and source are credited. "],["dge-analysis-workflow.html", "Chapter 4 DGE analysis workflow 4.1 Running DESeq2 4.2 DESeq2 differential gene expression analysis workflow", " Chapter 4 DGE analysis workflow Differential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Briefly, DESeq2 will: Alt text normalize the raw counts using size factors to account for differences in library depth estimate the gene-wise dispersions shrink these estimates to generate more accurate dispersion estimates fit the negative binomial (NG) model and perform hypothesis testing using the Wald test. This final step in the differential expression analysis workflow of fitting the raw counts to the NB model and performing the statistical test for differentially expressed genes, is the step we care about. This is the step that determines whether the mean expression levels of different sample groups are significantly different. Alt text The DESeq2 paper was published in 2014, but the package is continually updated and available for use in R through Bioconductor. 4.1 Running DESeq2 Prior to performing the differential expression analysis, it is a good idea to know what sources of variation are present in your data, either by exploration during the QC and/or prior knowledge. Once you know the major sources of variation, you can remove them prior to analysis or control for them in the statistical model by including them in your design formula. 4.1.1 Design formula A design formula tells the statistical software the known sources of variation to control for, as well as, the factor of interest to test for during differential expression testing. For example, if you know that sex is a significant source of variation in your data, then sex should be included in your model. The design formula should have all of the factors in your metadata that account for major sources of variation in your data. The last factor entered in the formula should be the condition of interest. For example, suppose you have the following metadata: Alt text If you want to examine the expression differences between treatments, and you know that major sources of variation include sex and age, then your design formula would be: design &lt;- ~ sex + age + treatment The tilde (~) should always proceed your factors and tells DESeq2 to model the counts using the following formula. Note the factors included in the design formula need to match the column names in the metadata. Exercises Suppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written? Based on our Mov10 metadata dataframe, which factors could we include in our design formula? What would you do if you wanted to include a factor in your design formula that is not in your metadata? 4.1.2 MOV10 DE analysis Now that we know how to specify the model to DESeq2, we can run the differential expression pipeline on the raw counts. To get our differential expression results from our raw count data, we only need to run 2 lines of code! First we create a DESeqDataSet as we did in the ‘Count normalization’ lesson and specify the location of our raw counts and metadata, and input our design formula: ## Create DESeq object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype) Then, to run the actual differential expression analysis, we use a single call to the function DESeq(). ## Run analysis dds &lt;- DESeq(dds) By re-assigning the results of the function back to the same variable name (dds), we can fill in the slots of our DESeqDataSet object. deseq1 Everything from normalization to linear modeling was carried out by the use of a single function! This function will print out a message for the various steps it performs: estimating size factors estimating dispersions gene-wise dispersion estimates mean-dispersion relationship final dispersion estimates fitting model and testing 4.2 DESeq2 differential gene expression analysis workflow With the 2 lines of code above, we just completed the workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below: Alt text We will be taking a detailed look at each of these steps to better understand how DESeq2 is performing the statistical analysis and what metrics we should examine to explore the quality of our analysis. 4.2.1 Step 1: Estimate size factors The first step in the differential expression analysis is to estimate the size factors, which is exactly what we already did to normalize the raw counts. Alt text DESeq2 will automatically estimate the size factors when performing the differential expression analysis. However, if you have already generated the size factors using estimateSizeFactors(), as we did earlier, then DESeq2 will use these values. To normalize the count data, DESeq2 calculates size factors for each sample using the median of ratios method discussed previously in the Count normalization (Chapter 2) lesson. 4.2.1.1 MOV10 DE analysis: examining the size factors Let’s take a quick look at size factor values we have for each sample: ## Check the size factors sizeFactors(dds) Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 Mov10_oe_3 Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 1.5646728 0.9351760 1.2016082 1.1205912 0.6534987 1.1224020 0.9625632 0.7477715 Take a look at the total number of reads for each sample: ## Total number of raw counts per sample colSums(counts(dds)) How do the numbers correlate with the size factor? 4.2.2 Step 2: Estimate gene-wise dispersion The next step in the differential expression analysis is the estimation of gene-wise dispersions. Before we get into the details, we should have a good idea about what dispersion is referring to in DESeq2. Alt text What is dispersion? Dispersion is a measure of spread or variability in the data. Variance, standard deviation, IQR, among other measures, can all be used to measure dispersion. However, DESeq2 uses a specific measure of dispersion (α) related to the mean (μ) and variance of the data: Var = μ + α*μ^2. For genes with moderate to high count values, the square root of dispersion will be equal to the coefficient of variation (σ / μ). So 0.01 dispersion means 10% variation around the mean expected across biological replicates. What does the DESeq2 dispersion represent? The DESeq2 dispersion estimates are inversely related to the mean and directly related to variance. Based on this relationship, the dispersion is higher for small mean counts and lower for large mean counts. The dispersion estimates for genes with the same mean will differ only based on their variance. Therefore, the dispersion estimates reflect the variance in gene expression for a given mean value. The plot of mean versus variance in count data below shows the variance in gene expression increases with the mean expression (each black dot is a gene). Notice that the relationship between mean and variance is linear on the log scale, and for higher means, we could predict the variance relatively accurately given the mean. However, for low mean counts, the variance estimates have a much larger spread; therefore, the dispersion estimates will differ much more between genes with small means. Alt text How does the dispersion relate to our model? To accurately model sequencing counts, we need to generate accurate estimates of within-group variation (variation between replicates of the same sample group) for each gene. With only a few (3-6) replicates per group, the estimates of variation for each gene are often unreliable (due to the large differences in dispersion for genes with similar means). To address this problem, DESeq2 shares information across genes to generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels have similar dispersion. Estimating the dispersion for each gene separately: The first step in estimating dispersion is to get the dispersion estimates for each gene. The dispersion for each gene is estimated using maximum likelihood estimation (MLE). MLE can be thought about as given the count values of the replicates, the most likely estimate of dispersion is calculated. 4.2.3 Step 3: Fit curve to gene-wise dispersion estimates The next step in the workflow is to fit a curve to the dispersion estimates for each gene. This curve represents the expected value of the dispersion given the expression values of the genes. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability, but, over all genes, there will be a distribution of reasonable estimates of dispersion. Alt text This curve is displayed as a red line in the figure below, which plots the estimate for the expected dispersion value for genes of a given expression strength. Each black dot is a gene with an associated mean expression level and maximum likelihood estimation (MLE) of the dispersion (Step 1). Alt text 4.2.4 Step 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve The next step in the workflow is to shrink the gene-wise dispersion estimates toward the expected dispersion values to get the final dispersion estimates. Alt text The curve allows for more accurate identification of differentially expressed genes when sample sizes are small, and the strength of the shrinkage for each gene depends on : how close gene dispersions are from the curve sample size (more samples = less shrinkage) This shrinkage method is particularly important to reduce false positives in the differential expression analysis. Genes with low dispersion estimates are shrunken towards the curve, and the more accurate, higher shrunken values are output for fitting of the model and differential expression testing. Dispersion estimates that are slightly above the curve are also shrunk toward the curve for better dispersion estimation; however, genes with extremely high dispersion values are not. This is due to the likelihood that the gene does not follow the modeling assumptions and has higher variability than others for biological or technical reasons and therefore is likely to be an outlier. Shrinking the values toward the curve could result in false positives, so these values are not shrunken. These dispersion outliers are shown surrounded by blue circles below. Alt text This is a good plot to examine to ensure your data is a good fit for the DESeq2 model. You expect your data to generally scatter around the curve, with the dispersion decreasing with increasing mean expression levels. If you see a cloud or different shapes, then you might want to explore your data more to see if you have contamination (mitochondrial, etc.) or outlier samples. Note how much shrinkage you get across the whole range of means in the plotDispEsts() plot for any experiment with low degrees of freedom. Examples of worrisome dispersion plots are shown below: Alt text Alt text 4.2.4.1 MOV10 DE analysis: exploring the dispersion estimates and assessing model fit Let’s take a look at the dispersion estimates for our MOV10 data: ## Plot dispersion estimates plotDispEsts(dds) Since we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model? "],["model-and-hypothesis-testing.html", "Chapter 5 Model and hypothesis testing 5.1 Generalized Linear Model fit for each gene 5.2 Shrunken log2 foldchanges (LFC) 5.3 Statistical test for LFC estimates: Wald test 5.4 Summarizing results", " Chapter 5 Model and hypothesis testing 5.1 Generalized Linear Model fit for each gene The final step in the DESeq2 workflow is fitting the Negative Binomial model for each gene and performing differential expression testing. Alt text The first step in performing differential expression analysis is to model the RNA-seq counts. DESeq2 fits a negative binomial generalized linear model (GLM) to estimatae the counts for each gene. A generalized linear model (GLM) is a statistical method that allows you to model relationships between different variables. It’s similar to a linear regression model, which fits data to a line, but it can handle data that is not normally distributed, such as data that is binary or count data. The two parameters required to fit the negative binomial GLM are the size factor, and the dispersion estimate. The model incorporates the estimated dispersion and the design matrix, which specifies the experimental conditions and any covariates of interest. The negative binomial model is shown below: Alt text where \\(K_{ij}\\) are the raw counts for gene i in sample j. After the model is fit, coefficients are estimated for each sample group along with their standard error. These coefficients are the estimates for the log2 fold changes using the following model: Alt text An easier way of writing this is: \\[\\LARGE y = \\beta_0 + \\beta_1x_{1} + \\beta_2x_{2} + ...\\] Here, \\(y\\) is the log2 fitted counts for each gene taking dispersion into account, \\(x_{i}\\) is the design factor i (e.g control = 0, case = 1) and the \\(\\beta\\) coefficients are the Log2 Fold Changes (LFC) for each sample. In our dataset the design has three levels, and can be written like this: \\[\\LARGE y = \\beta_0 + \\beta_1 x_{mov10kd} + \\beta_2 x_{mov10oe}\\] Where: \\(y\\) is the log2 of the fitted counts for each gene \\(\\beta_0\\) is the log2 average of the reference group (in this example “control”) \\(\\beta_1\\) is the log2 fold difference between “Mov10_kd” and the reference group “control” \\(\\beta_2\\) is the log2 fold difference between “Mov10_oe” and the reference group “control” \\(x_{mov10kd}\\) indicates whether a sample belongs to group Mov10_kd or not. \\(x_{mov10oe}\\) indicates whether a sample belongs to group Mov10_oe or not. The \\(\\beta\\) coefficents are the estimates for the log2 fold changes for each sample group. However, log2 fold changes are inherently noisier when counts are low due to the large dispersion we observe with low read counts. To avoid this, the log2 fold changes calculated by the model need to be adjusted. 5.2 Shrunken log2 foldchanges (LFC) To generate more accurate LFC estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include: Low counts High dispersion values As with the shrinkage of dispersion estimates, LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates. Alt text Illustration taken from the DESeq2 paper. For example, in the figure above, the green gene and purple gene have the same mean values for the two sample groups (C57BL/6J and DBA/2J), but the green gene has little variation while the purple gene has high levels of variation. For the green gene with low variation, the unshrunken LFC estimate (vertex of the green solid line) is very similar to the shrunken LFC estimate (vertex of the green dotted line), but the LFC estimates for the purple gene are quite different due to the high dispersion. So even though two genes can have similar normalized count values, they can have differing degrees of LFC shrinkage. Notice the LFC estimates are shrunken toward the prior (black solid line). To generate the shrunken log2 fold change estimates, you have to run an additional step on your results object (that we will create below) with the function lfcShrink(). 5.3 Statistical test for LFC estimates: Wald test In DESeq2, the Wald test is the default used for hypothesis testing when comparing two groups. The Wald test is a test usually performed on the LFC estimates. DESeq2 implements the Wald test by: Taking the LFC and dividing it by its standard error, resulting in a z-statistic The z-statistic is compared to a standard normal distribution, and a p-value is computed reporting the probability that a z-statistic at least as extreme as the observed value would be selected at random If the p-value is small we reject the null hypothesis (LFC = 0) and state that there is evidence against the null (i.e. the gene is differentially expressed). 5.3.1 Overall DESeq2 workflow: Estimate Size Factor Estimate Dispersions Fit negative binomial GLM Hypothesis Testing 5.3.2 Creating contrasts To indicate to DESeq2 the two groups we want to compare, we can use contrasts. Contrasts are then provided to DESeq2 to perform differential expression testing using the Wald test. Contrasts can be provided to DESeq2 a couple of different ways: Do nothing. Automatically DESeq2 will use the base factor level of the condition of interest as the base for statistical testing. The base level is chosen based on alphabetical order of the levels. In the results() function you can specify the comparison of interest, and the levels to compare. The level given last is the base level for the comparison. The syntax is given below: # DO NOT RUN! contrast &lt;- c(&quot;condition&quot;, &quot;level_to_compare&quot;, &quot;base_level&quot;) results(dds, contrast = contrast, alpha = alpha_threshold) The alpha threshold is the significance cutoff used for optimizing the independent filtering. After testing your genes and getting p-values, DESeq2 performs a step which is called “independent filtering” and the goal is to remove genes with very low counts because these usually have low power to be detected as significant in the first place, because of high dispersion (you remove them even without looking at their p-values). The alpha in threshold in results controls how this procedure is made, and it should be set to the threshold that you want to use in your adjusted p-values (e.g. 0.05). 5.3.2.1 MOV10 DE analysis: contrasts and Wald tests We have three sample classes so we can make three possible pairwise comparisons: Control vs. Mov10 overexpression Control vs. Mov10 knockdown Mov10 knockdown vs. Mov10 overexpression We are really only interested in #1 and #2 from above. Using the design formula we provided ~ sampletype, indicating that this is our main factor of interest. 5.3.3 Building the results table To build our results table we will use the results() function. To tell DESeq2 which groups we wish to compare, we supply the contrasts we would like to make using thecontrast argument. For this example we will save the unshrunken and shrunken versions of results to separate variables. Additionally, we are including the alpha argument and setting it to 0.05. This is the significance cutoff used for optimizing the independent filtering (by default it is set to 0.1). If the adjusted p-value cutoff (FDR) will be a value other than 0.1 (for our final list of significant genes), alpha should be set to that value. ## Define contrasts, extract results table, and shrink the log2 fold changes contrast_oe &lt;- c(&quot;sampletype&quot;, &quot;MOV10_overexpression&quot;, &quot;control&quot;) res_tableOE_unshrunken &lt;- results(dds, contrast=contrast_oe, alpha = 0.05) resultsNames(dds) res_tableOE &lt;- lfcShrink(dds = dds,coef=&quot;sampletype_MOV10_overexpression_vs_control&quot;,res=res_tableOE_unshrunken) The order of the names determines the direction of fold change that is reported. The name provided in the second element is the level that is used as baseline. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in Mov10_oe relative to the control. 5.3.4 MA Plot A plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot. Let’s start with the unshrunken results: plotMA(res_tableOE_unshrunken, ylim=c(-2,2)) Alt text And now the shrunken results: plotMA(res_tableOE, ylim=c(-2,2)) Alt text In addition to the comparison described above, this plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression. Generally, we would expect to see significant genes across the full range of expression levels. 5.3.5 MOV10 DE analysis: results exploration The results table looks very much like a dataframe and in many ways it can be treated like one (i.e when accessing/subsetting data). However, it is important to recognize that it is actually stored in a DESeqResults object. When we start visualizing our data, this information will be helpful. class(res_tableOE) Let’s go through some of the columns in the results table to get a better idea of what we are looking at. To extract information regarding the meaning of each column we can use mcols(): mcols(res_tableOE, use.names=T) baseMean: mean of normalized counts for all samples log2FoldChange: log2 fold change lfcSE: standard error stat: Wald statistic pvalue: Wald test p-value padj: BH adjusted p-values Now let’s take a look at what information is stored in the results: res_tableOE %&gt;% data.frame() %&gt;% head() log2 fold change (MAP): sampletype MOV10_overexpression vs control Wald test p-value: sampletype MOV10_overexpression vs control DataFrame with 6 rows and 6 columns baseMean log2FoldChange lfcSE stat pvalue padj &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; &lt;numeric&gt; 1/2-SBSRNA4 45.6520399 0.26976764 0.18775752 1.4367874 0.1507784 0.25242910 A1BG 61.0931017 0.20999700 0.17315013 1.2128030 0.2252051 0.34444163 A1BG-AS1 175.6658069 -0.05197768 0.12366259 -0.4203185 0.6742528 0.77216278 A1CF 0.2376919 0.02237286 0.04577046 0.4888056 0.6249793 NA A2LD1 89.6179845 0.34598540 0.15901426 2.1758136 0.0295692 0.06725157 A2M 5.8600841 -0.27850841 0.18051805 -1.5428286 0.1228724 0.21489067 NOTE: on p-values set to NA &gt; 1. If within a row, all samples have zero counts, the baseMean column will be zero, and the log2 fold change estimates, p-value and adjusted p-value will all be set to NA. 2. If a row contains a sample with an extreme count outlier then the p-value and adjusted p-value will be set to NA. These outlier counts are detected by Cook’s distance. 3. If a row is filtered by automatic independent filtering, for having a low mean normalized count, then only the adjusted p-value will be set to NA. 5.3.6 Multiple test correction Note that we have pvalues and p-adjusted values in the output. Which should we use to identify significantly differentially expressed genes? If we used the p-value directly from the Wald test with a significance cut-off of p &lt; 0.05, that means there is a 5% chance it is a false positives. Each p-value is the result of a single test (single gene). The more genes we test, the more we inflate the false positive rate. This is the multiple testing problem. For example, if we test 20,000 genes for differential expression, at p &lt; 0.05 we would expect to find 1,000 genes by chance. If we found 3000 genes to be differentially expressed total, 150 of our genes are false positives. We would not want to sift through our “significant” genes to identify which ones are true positives. DESeq2 helps reduce the number of genes tested by removing those genes unlikely to be significantly DE prior to testing, such as those with low number of counts and outlier samples (gene-level QC). However, we still need to correct for multiple testing to reduce the number of false positives, and there are a few common approaches: Bonferroni: The adjusted p-value is calculated by: p-value * m (m = total number of tests). This is a very conservative approach with a high probability of false negatives, so is generally not recommended. FDR/Benjamini-Hochberg: Benjamini and Hochberg (1995) defined the concept of FDR and created an algorithm to control the expected FDR below a specified level given a list of independent p-values. An interpretation of the BH method for controlling the FDR is implemented in DESeq2 in which we rank the genes by p-value, then multiply each ranked p-value by m/rank where m is the number of tests. In DESeq2, the p-values attained by the Wald test are corrected for multiple testing using the Benjamini and Hochberg method by default. There are options to use other methods in the results() function. The p-adjusted values should be used to determine significant genes. The significant genes can be output for visualization and/or functional analysis. 5.3.7 MOV10 DE analysis: Control versus Knockdown Now that we have results for the overexpression results, let’s do the same for the Control vs. Knockdown samples. Use contrasts in the results() to extract a results table and store that to a variable called res_tableKD. ## Define contrasts, extract results table and shrink log2 fold changes contrast_kd &lt;- c(&quot;sampletype&quot;, &quot;MOV10_knockdown&quot;, &quot;control&quot;) res_tableKD_unshrunken &lt;- results(dds, contrast=contrast_kd, alpha = 0.05) resultsNames(dds) res_tableKD &lt;- lfcShrink(dds, coef = 2, res=res_tableKD_unshrunken) # We will save these results for later use in the data directory using the following command: saveRDS(res_tableKD, file = &quot;data/res_tableKD.rds&quot;) # just for security, save all our objects in &quot;.RData&quot; again: save.image() Take a quick peek at the results table containing Wald test statistics for the Control-Knockdown comparison we are interested in and make sure that format is similar to what we observed with the OE. 5.4 Summarizing results To summarize the results table, a handy function in DESeq2 is summary(). Confusingly it has the same name as the function used to inspect data frames. This function when called with a DESeq results table as input, will summarize the results using the alpha threshold: FDR &lt; 0.05 (padj/FDR is used even though the output says p-value &lt; 0.05). Let’s start with the OE vs control results: ## Summarize results summary(res_tableOE) In addition to the number of genes up- and down-regulated at the default threshold, the function also reports the number of genes that were tested (genes with non-zero total read count), and the number of genes not included in multiple test correction due to a low mean count. 5.4.1 Extracting significant differentially expressed genes What we noticed is that the FDR threshold on it’s own doesn’t appear to be reducing the number of significant genes. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also add a fold change threshold. The summary() function doesn’t have an argument for fold change threshold. Let’s first create variables that contain our threshold criteria: ### Set thresholds padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 The lfc.cutoff is set to 0.58; remember that we are working with log2 fold changes so this translates to an actual fold change of 1.5 which is pretty reasonable. We can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble: res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() Now we can subset that table to only keep the significant genes using our pre-defined thresholds: sigOE &lt;- res_tableOE_tb %&gt;% filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) How many genes are differentially expressed in the Overexpression compared to Control, given our criteria specified above? Does this reduce our results? Using the same thresholds as above (padj.cutoff &lt; 0.05 and lfc.cutoff = 0.58), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control. res_tableKD_tb &lt;- res_tableKD %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() sigKD &lt;- res_tableKD_tb %&gt;% filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) How many genes are differentially expressed in the Knockdown compared to Control? Now that we have subsetted our data, we are ready for visualization! "],["visualizing-rna-seq-results.html", "Chapter 6 Visualizing RNA-seq results", " Chapter 6 Visualizing RNA-seq results During this lesson, we will get you started with some basic and more advanced plots commonly used when exploring differential gene expression data. Let’s start by loading a few libraries (if not already loaded): # load libraries library(tidyverse) library(ggplot2) library(ggrepel) library(RColorBrewer) library(DESeq2) library(pheatmap) NOTE: Since we are using the tidyverse suite of packages, we may run into conflicts with functions that have the same name but are part of different packages (i.e filter). If you run the code and run into an error try re-running the code using syntax where you specify package explicitly (i.e dplyr::filter). We will be working with three different data objects we have already created in earlier lessons: Metadata for our samples (a dataframe): meta Normalized expression data for every gene in each of our samples (a matrix): normalized_counts Tibble versions of the DESeq2 results we generated in the last lesson: res_tableOE_tb and res_tableKD_tb Let’s create tibble objects from the meta and normalized_counts data frames before we start plotting. This will enable us to use the tidyverse functionality more easily. # Create a tibble for meta data mov10_meta &lt;- meta %&gt;% rownames_to_column(var=&quot;samplename&quot;) %&gt;% as_tibble() # you might to read in normalized_counts if it is not in your current session: normalized_counts &lt;- read.delim(&quot;data/normalized_counts.txt&quot;, row.names=1) # then make sure the colnames of normalized_counts are the same as the mov10_meta$sampname all(mov10_meta$samplename == colnames(normalized_counts)) # if they aren&#39;t we need to reorder them # mtch = match(mov10_meta$samplename, # colnames(normalized_counts)) # normalized_counts &lt;- normalized_counts[,mtch] # all(mov10_meta$samplename == colnames(normalized_counts)) # Create a tibble for normalized_counts normalized_counts &lt;- normalized_counts %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() 6.0.1 Plotting signicant DE genes One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes. 6.0.1.1 Using DESeq2 plotCounts() to plot expression of a single gene To pick out a specific gene of interest to plot, for example Mov10, we can use the plotCounts() from DESeq2: # Plot expression for single gene plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;) # we can give it some color and filled points: sampletype = as.factor(mov10_meta$sampletype) library(RColorBrewer) display.brewer.all() col = brewer.pal(8,&quot;Dark2&quot;) palette(col) plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;,col = as.numeric(sampletype),pch = 19) topgene This function only allows for plotting the counts of a single gene at a time. 6.0.1.2 Using ggplot2 to plot expression of a single gene We can also use ggplot2 to plot the MOV10 counts. We can save the output of plotCounts() to a variable specifying the returnData=TRUE argument, then use ggplot(): # Save plotcounts to a data frame object d &lt;- plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;, returnData=TRUE) # Plotting the MOV10 normalized counts, using the samplenames (rownames of d as labels) ggplot(d, aes(x = sampletype, y = count, color = sampletype)) + geom_point(position=position_jitter(w = 0.1,h = 0)) + geom_text_repel(aes(label = rownames(d))) + theme_bw() + ggtitle(&quot;MOV10&quot;) + theme(plot.title = element_text(hjust = 0.5)) Note that in the plot below (code above), we are using geom_text_repel() from the ggrepel package to label our individual points on the plot. Alt text 6.0.1.3 Using ggplot2 to plot multiple genes (e.g. top 20) Often it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling. We are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). To do this, we first need to determine the gene names of our top 20 genes by ordering our results and extracting the top 20 genes (by padj values): ## Order results by padj values top20_sigOE_genes &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% #Arrange rows by padj values pull(gene) %&gt;% #Extract character vector of ordered genes head(n=20) #Extract the first 20 genes Then, we can extract the normalized count values for these top 20 genes: ## normalized counts for top 20 significant genes top20_sigOE_norm &lt;- normalized_counts %&gt;% filter(gene %in% top20_sigOE_genes) Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to pivot_longer top20_sigOE_norm from a wide format to a long format so the counts for all samples will be in a single column to allow us to give ggplot the one column with the values we want it to plot. The pivot_longer() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth. Alt text # Pivoting the columns to have normalized counts to a single column pivoted_top20_sigOE &lt;- top20_sigOE_norm %&gt;% pivot_longer(colnames(top20_sigOE_norm)[2:9], names_to = &quot;samplename&quot;, values_to = &quot;normalized_counts&quot;) ## check the column header in the &quot;pivoted&quot; data frame head(pivoted_top20_sigOE) Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot(): # `inner_join(x,y)` will merge 2 data frames by the colname in x that matches a column name in y. it is similar to doing a match(pivoted_top20_sigOE$samplename, mov10_meta$samplename) and then adding sampletype andn MOV10exr to pivoted_top20_sigOE$samplename, but it is more efficient because the columns from mov10_meta are added in a single command. pivoted_top20_sigOE &lt;- inner_join(mov10_meta, pivoted_top20_sigOE) Now that we have a data frame in a format that can be utilised by ggplot easily, let’s plot! ## plot using ggplot2 ggplot(pivoted_top20_sigOE) + geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) + scale_y_log10() + xlab(&quot;Genes&quot;) + ylab(&quot;log10 Normalized Counts&quot;) + ggtitle(&quot;Top 20 Significant DE Genes&quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(plot.title = element_text(hjust = 0.5)) Alt text 6.0.2 Heatmap In addition to plotting subsets, we could also extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap(). ### Extract normalized expression for significant genes from the OE and control samples c(2:4,7:9), and set the gene column (1) to row names norm_OEsig &lt;- normalized_counts[,c(1,2:4,7:9)] %&gt;% filter(gene %in% sigOE$gene) %&gt;% data.frame() %&gt;% column_to_rownames(var = &quot;gene&quot;) Now let’s draw the heatmap using pheatmap: ### Annotate our heatmap (optional) annotation &lt;- mov10_meta %&gt;% select(samplename, sampletype) %&gt;% data.frame(row.names = &quot;samplename&quot;) ### Set a color palette heat_colors &lt;- brewer.pal(6, &quot;YlOrRd&quot;) ### Run pheatmap pheatmap(norm_OEsig, color = heat_colors, cluster_rows = T, show_rownames = F, annotation = annotation, border_color = NA, fontsize = 10, scale = &quot;row&quot;, fontsize_row = 10, height = 20) Alt text NOTE: There are several additional arguments we have included in the function for aesthetics. One important one is scale=\"row\", in which Z-scores are plotted, rather than the actual normalized count value. Z-scores are computed on a gene-by-gene basis by subtracting the mean and then dividing by the standard deviation. The Z-scores are computed after the clustering, so that it only affects the graphical aesthetics and the color visualization is improved. 6.0.3 Volcano plot The above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis. To generate a volcano plot, we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values. ## Obtain logical vector where TRUE values denote padj values &lt; 0.05 and fold change &gt; 1.5 in either direction res_tableOE_tb &lt;- res_tableOE_tb %&gt;% mutate(threshold_OE = padj &lt; 0.05 &amp; abs(log2FoldChange) &gt;= 0.58) Now we can start plotting. The geom_point object is most applicable, as this is essentially a scatter plot: ## Volcano plot ggplot(res_tableOE_tb) + geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold_OE)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + #scale_y_continuous(limits = c(0,50)) + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) Alt text This is a great way to get an overall picture of what is going on, but what if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using geom_text_repel(). First, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot. ## Create a column to indicate which genes to label res_tableOE_tb &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% mutate(genelabels = &quot;&quot;) res_tableOE_tb$genelabels[1:10] &lt;- res_tableOE_tb$gene[1:10] head(res_tableOE_tb) Next, we plot it as before with an additiona layer for geom_text_repel() wherein we can specify the column of gene labels we just created. ggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) + geom_point(aes(colour = threshold_OE)) + geom_text_repel(aes(label = genelabels)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) Alt text "],["summary-of-dge-workflow.html", "Chapter 7 Summary of DGE workflow", " Chapter 7 Summary of DGE workflow We have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below: Count normalization: # Check that the row names of the metadata equal the column names of the **raw counts** data all(colnames(raw_counts) == rownames(metadata)) # Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition) Exploratory data analysis (PCA &amp; heirarchical clustering) - identifying outliers and sources of variation in the data: # Transform counts for data visualization rld &lt;- rlog(dds, blind=TRUE) # Plot PCA plotPCA(rld, intgroup=&quot;condition&quot;) # Extract the rlog matrix from the object rld_mat &lt;- assay(rld) # Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) # Plot heatmap pheatmap(rld_cor) Run DESeq2: # **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition) # Run DESeq2 differential expression analysis dds &lt;- DESeq(dds) # **Optional step** - Output normalized counts to save as a file to access outside RStudio normalized_counts &lt;- counts(dds, normalized=TRUE) Check the fit of the dispersion estimates: # Plot dispersion estimates plotDispEsts(dds) Create contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions: # Output results of Wald test for contrast contrast &lt;- c(&quot;condition&quot;, &quot;level_to_compare&quot;, &quot;base_level&quot;) res &lt;- results(dds, contrast = contrast) coef = resultsNames(dds) res_tableOE &lt;- lfcShrink(dds, coef = coef[?], res=res, type = &quot;apeglm&quot;) Output significant results: # Turn the results object into a data frame res_df &lt;- res %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) # Subset the significant results sig_res &lt;- filter(res_df, padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) Visualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc. Make sure to output the versions of all tools used in the DE analysis: sessionInfo() "],["functional-analysis-of-rnaseq-data.html", "Chapter 8 Functional analysis of RNAseq data", " Chapter 8 Functional analysis of RNAseq data Functional analysis tools are useful in interpreting resulting DGE gene lists from RNAseq, and fall into three main types: Over-representation analysis Functional class scoring Pathway topology 8.0.1 Over-representation analysis To determine whether any GO terms are over-represented in a significant gene list, the probability of the observed proportion of genes associated with a specific term is compared to the probability of the background set of genes belonging to the same term. This statistical test is known as the “hypergeometric test”. We will be using clusterProfiler 8.0.2 clusterProfiler # you may have to install some of these libraries; use # BiocManager::install(c(&quot;org.Hs.eg.db&quot;,&quot;clusterProfiler&quot;,&quot;enrichplot&quot;,&quot;fgsea&quot;)) library(org.Hs.eg.db) library(clusterProfiler) library(tidyverse) library(enrichplot) library(fgsea) 8.0.2.1 Running clusterProfiler res_tableOE = readRDS(&quot;data/res_tableOE.rds&quot;) res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% dplyr::filter(!is.na(log2FoldChange)) %&gt;% as_tibble() To perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes). ## background set of ensgenes allOE_genes &lt;- res_tableOE_tb$gene sigOE = dplyr::filter(res_tableOE_tb, padj &lt; 0.05) sigOE_genes = sigOE$gene Now we can perform the GO enrichment analysis and save the results: ## Run GO enrichment analysis ego &lt;- enrichGO(gene = sigOE_genes, universe = allOE_genes, keyType = &quot;SYMBOL&quot;, OrgDb = org.Hs.eg.db, minGSSize = 20, maxGSSize = 300, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 0.05, readable = TRUE) ## Output results from GO analysis to a table cluster_summary &lt;- data.frame(ego) ## make sure you have a results directory write.csv(cluster_summary, &quot;results/clusterProfiler_Mov10oe.csv&quot;) 8.0.2.2 Visualizing clusterProfiler results dotplot The dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 50 genes by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value. ## Dotplot ## dotplot(ego, showCategory=50) To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF….set PDF size to 8 x 14 to give a figure of appropriate size for the text labels enrichment GO plot The next plot is the enrichment GO plot, which shows the relationship between the top 50 most significantly enriched GO terms (padj.), by grouping similar terms together. The color represents the p-values relative to the other displayed terms (brighter red is more significant) and the size of the terms represents the number of genes that are significant from our list. This plot is useful because it serves to collapse the GO terms into functional categories by showing the overlap between GO terms. ## Enrichmap clusters the 50 most significant (by padj) GO terms to visualize relationships between terms pwt &lt;- pairwise_termsim( ego, method = &quot;JC&quot;, semData = NULL, showCategory = 50 ) emapplot(pwt, showCategory = 50) ## Warning: ggrepel: 9 unlabeled data points (too many overlaps). Consider increasing ## max.overlaps To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF…. In the pop-up window, change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels. Finally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the pvalues of the terms, with the more significant terms being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes. netplot ## To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector OE_foldchanges &lt;- sigOE$log2FoldChange names(OE_foldchanges) &lt;- sigOE$gene ## Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj) cnetplot(ego, categorySize=&quot;pvalue&quot;, showCategory = 5, foldChange = OE_foldchanges, vertex.label.font=6) ## Warning in cnetplot.enrichResult(x, ...): Use &#39;color.params = list(foldChange = your_value)&#39; instead of &#39;foldChange&#39;. ## The foldChange parameter will be removed in the next version. ## Warning: ggrepel: 436 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps Again, to save the figure, click on the Export button in the RStudio Plots tab and Save as PDF…. Change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels. 8.0.3 Gene set enrichment analysis (GSEA) 8.0.3.1 GSEA using clusterProfiler GSEA uses the entire list of log2 fold changes from all genes. It is based on looking for enrichment of genesets among the large positive or negative fold changes. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. Extract and name the fold changes: ## Extract the foldchanges foldchanges &lt;- res_tableOE_tb$log2FoldChange ## Name each fold change with the corresponding Entrez ID names(foldchanges) &lt;- res_tableOE_tb$gene Next we need to order the fold changes in decreasing order. To do this we’ll use the sort() function, which takes a vector as input. This is in contrast to Tidyverse’s arrange(), which requires a data frame. ## Sort fold changes in decreasing order foldchanges &lt;- sort(foldchanges, decreasing = TRUE) head(foldchanges) ## HSPA6 MOV10 ASCL1 HSPA7 SCRT1 SIGLEC14 ## 6.246267 5.079630 4.441203 3.637040 2.925440 2.615129 We can explore the enrichment of BP Gene Ontology terms using gene set enrichment analysis: # GSEA using gene sets associated with BP Gene Ontology terms gseaGO &lt;- clusterProfiler::gseGO( geneList = foldchanges, ont = &quot;BP&quot;, keyType = &quot;SYMBOL&quot;, eps = 0, minGSSize = 20, maxGSSize = 300, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05, verbose = TRUE, OrgDb = &quot;org.Hs.eg.db&quot;, by = &quot;fgsea&quot; ) ## using &#39;fgsea&#39; for GSEA analysis, please cite Korotkevich et al (2019). ## preparing geneSet collections... ## GSEA analysis... ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (8.07% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## leading edge analysis... ## done... gseaGO_results &lt;- gseaGO@result goplot(gseaGO) # default is 10 categories ## Warning: ggrepel: 84 unlabeled data points (too many overlaps). Consider increasing ## max.overlaps gseaplot2(gseaGO, geneSetID = 1:3) We can also use our homemade GO enrichment analysis. To do this we need to load the library GOenrichment: # Uncomment the following if you haven&#39;t yet installed GOenrichment. # devtools::install_github(&quot;gurinina/GOenrichment&quot;) library(GOenrichment) ls(&quot;package:GOenrichment&quot;) ## [1] &quot;compSCORE&quot; &quot;dfGOBP&quot; &quot;hGOBP.gmt&quot; &quot;hyperG&quot; &quot;runGORESP&quot; ## [6] &quot;runNetwork&quot; &quot;sampleFitdata&quot; &quot;visSetup&quot; &quot;yGOBP.gmt&quot; One of the problems with GO enrichment analysis is that the GO annotations are in constant flux. Here we can use the GO annotations in hGOBP.gmt (downloaded recently) to run GSEA using the fgsea package to run GSEA: fgseaRes &lt;- fgsea::fgseaSimple(pathways = hGOBP.gmt,stats=foldchanges,nperm=1000,maxSize = 300,minSize = 20) ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (8.07% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. fgsea &lt;- data.frame(fgseaRes,stringsAsFactors = F) w = which(fgsea$ES &gt; 0) fposgsea &lt;- fgsea[w,] fposgsea &lt;- fposgsea %&gt;% arrange(padj) We are going to compare these results to runing the GO enrichment function runGORESP. runGORESP uses over-representation analysis to identify enriched GO terms, so we need to define a significance cutoff for the querySet. args(runGORESP) ## function (mat, coln, curr_exp = colnames(mat)[coln], sig = 1, ## fdrThresh = 0.2, bp_path = NULL, bp_input = NULL, go_path = NULL, ## go_input = NULL, minSetSize = 5, maxSetSize = 300) ## NULL ?runGORESP # we&#39;ll define our significance cutoff as 0.58, corresponding to 1.5x change. # `runGORESP` requires a matrix, so we can turn foldchanges into a matrix using `cbind`: matx &lt;- cbind(foldchanges,foldchanges) hresp = GOenrichment::runGORESP(fdrThresh = 0.2,mat=matx, coln=1,curr_exp = colnames(matx)[1], sig = 0.58, bp_input = hGOBP.gmt,go_input = NULL,minSetSize = 20, maxSetSize = 300) names(hresp$edgeMat) ## [1] &quot;source&quot; &quot;target&quot; &quot;overlapCoeff&quot; &quot;width&quot; &quot;label&quot; names(hresp$enrichInfo) ## [1] &quot;filename&quot; &quot;term&quot; &quot;nGenes&quot; ## [4] &quot;nQuery&quot; &quot;nOverlap&quot; &quot;querySetFraction&quot; ## [7] &quot;geneSetFraction&quot; &quot;foldEnrichment&quot; &quot;P&quot; ## [10] &quot;FDR&quot; &quot;overlapGenes&quot; &quot;maxOverlapGeneScore&quot; ## [13] &quot;cluster&quot; &quot;id&quot; &quot;size&quot; ## [16] &quot;formattedLabel&quot; # View(hresp$enrichInfo[,c(2,3,4,5,10)]) Let’s check the overlap between the enriched terms found using runGORESP and those found using fgseaSimple as they used the same GO term libraries: w = which(fposgsea$padj &lt;= 0.2) lens &lt;- length(intersect(fposgsea$pathway[w],hresp$enrichInfo$term)) length(w) ## [1] 575 dim(hresp$enrichInfo) ## [1] 238 16 percent_overlap &lt;- lens/nrow(hresp$enrichInfo)*100 percent_overlap ## [1] 82.35294 80%, that’s very good, especially because we are using two different GO enrichment methods, over-representation analysis and GSEA. The overlap between these enrichment and the ones using the other GO enrichment tools will be very small because of the differences in the GO annotation libraries. Now to set up the results for viewing in a network, we use the function visSetup, which creates a set of nodes and edges in the network, where nodes are GO terms (node size proportional to FDR score) and edges represent the overlap between GO terms (proportional to edge width). This network analysis is based on Cytoscape, an open source bioinformatics software platform for visualizing molecular interaction networks. vis = visSetup(hresp$enrichInfo,hresp$edgeMat) names(vis) ## [1] &quot;nodes&quot; &quot;edges&quot; Now we use runNetwork to view the map: runNetwork(vis$nodes,vis$edges) This is one of the best visualizations available out of all the GO packages. There are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, such as a GMT for MSigDB called c2. ** The C2 subcollection CGP: Chemical and genetic perturbations. Gene sets that represent expression signatures of genetic and chemical perturbations.** 8.0.4 Other tools and resources GeneMANIA. GeneMANIA finds other genes that are related to a set of input genes, using a very large set of functional association data curated from the literature. Association data include protein and genetic interactions, pathways, co-expression, co-localization and protein domain similarity. ReviGO. Revigo is an online GO enrichment tool that allows you to copy-paste your significant gene list and your background gene list. The output is a visualization of enriched GO terms in a hierarchical tree. AmiGO. AmiGO is the current official web-based set of tools for searching and browsing the Gene Ontology database. DAVID. The fold enrichment is defined as the ratio of the two proportions; one is the proportion of genes in your list belong to certain pathway, and the other is the proportion of genes in the background information (i.e., universe genes) that belong to that pathway. etc. "],["codebook.html", "Chapter 9 Codebook 9.1 DGE analysis overview 9.2 Count normalization 9.3 DGE QC analysis 9.4 DEG analysis workflow 9.5 Model fitting 9.6 Visualizing rna-seq results 9.7 Summary of differential expression analysis workflow 9.8 Functional analysis of RNA-seq data", " Chapter 9 Codebook 20 total points 9.1 DGE analysis overview .md file = 01-DGE_setup_and_overview.md 9.1.1 Review of the dataset RNA-Seq was performed on HEK293F cells that were either transfected with a MOV10 transgene, or siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions Mov10 oe (over expression), Mov10 kd (knock down) and Irrelevant kd, respectively. The number of replicates is as shown below. Using these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition. Our questions: * What patterns of expression can we identify with the loss or gain of MOV10? * Are there any genes shared between the two conditions? 9.1.2 Setting up 9.1.2.1 Loading libraries ### Setup: Use BiocManager::install if you haven&#39;t already installed these libraries ### ### BiocManager::install(c(&quot;tidyverse&quot;,&quot;RColorBrewer&quot;,&quot;DESeq2&quot;,&quot;pheatmap&quot;,&quot;ggplot2&quot;,&quot;ggrepel&quot;)) ### Bioconductor and CRAN libraries used library(tidyverse) library(RColorBrewer) library(DESeq2) library(pheatmap) library(ggplot2) library(ggrepel) 9.1.2.2 Loading data ## Load in data data &lt;- read.delim(&quot;data/Mov10_full_counts.txt&quot;, row.names=1) meta &lt;- read.delim(&quot;meta/Mov10_full_meta.txt&quot;, row.names=1) Use class() to inspect our data and make sure we are working with data frames: ### Check classes of the data we just brought in class(meta) ## [1] &quot;data.frame&quot; class(data) ## [1] &quot;data.frame&quot; 9.1.2.3 Viewing data head(meta) sampletype MOVexpr Irrel_kd_1 control normal Irrel_kd_2 control normal Irrel_kd_3 control normal Mov10_kd_2 MOV10_knockdown low Mov10_kd_3 MOV10_knockdown low Mov10_oe_1 MOV10_overexpression high head(data[,1:5]) Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 Mov10_oe_3 1/2-SBSRNA4 57 41 64 55 38 A1BG 71 40 100 81 41 A1BG-AS1 256 177 220 189 107 A1CF 0 1 1 0 0 A2LD1 146 81 138 125 52 A2M 10 9 2 5 2 9.1.3 DGE analysis workflow 9.1.3.1 RNA-seq count distribution To determine the appropriate statistical model, we need information about the distribution of counts. To get an idea about how RNA-seq counts are distributed, let’s plot the counts for a single sample, ‘Mov10_oe_1’: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) If we zoom in close to zero, we can see a large number of genes with counts of zero: ggplot(data) + geom_histogram(aes(x = Mov10_oe_1), stat = &quot;bin&quot;, bins = 200) + xlim(-5, 500) + xlab(&quot;Raw expression counts&quot;) + ylab(&quot;Number of genes&quot;) ## Warning: Removed 9121 rows containing non-finite outside the scale range ## (`stat_bin()`). ## Warning: Removed 2 rows containing missing values or values outside the scale range ## (`geom_bar()`). These images illustrate some common features of RNA-seq count data, including a low number of counts associated with a large proportion of genes, and a long right tail due to the lack of any upper limit for expression. 9.1.3.2 Modeling count data By plotting the mean versus the variance of our data we should be able to see that the variance &gt; mean and therefore it does not fit the Poisson distribution and is better suited to the Negative Binomial (NB) model. Run the following code to plot the mean versus variance for the ‘Mov10 overexpression’ replicates: # apply applies a function to the margins of a matrix # apply(X, MARGIN, FUN) # where X is a matrix # to apply a function to each row of a matrix, use MARGIN = 1 # to apply a function to each column of a matrix, use MARGIN = 2 # FUN can be any function mean_counts &lt;- apply(data[, 3:5], 1, mean) variance_counts &lt;- apply(data[, 3:5], 1, var) # for ggplot we need the data to be in a data.frame df &lt;- data.frame(mean_counts, variance_counts) ggplot(df) + geom_point(aes(x=mean_counts, y=variance_counts)) + geom_line(aes(x=mean_counts, y=mean_counts, color=&quot;red&quot;)) + scale_y_log10() + scale_x_log10() ## Warning in scale_y_log10(): log-10 transformation introduced infinite values. ## Warning in scale_x_log10(): log-10 transformation introduced infinite values. ## Warning in scale_y_log10(): log-10 transformation introduced infinite values. ## Warning in scale_x_log10(): log-10 transformation introduced infinite values. Note that in the above figure, the variance across replicates tends to be greater than the mean (slope &gt; 1, red line), especially for genes with large mean expression levels. This is a good indication that our data do not fit the Poisson distribution and we need to account for this increase in variance using the Negative Binomial model. 9.2 Count normalization .md file = 02-DGE_count_normalization.md 9.2.1 Normalization The steps fpr DESeq2 median of ratios method: calculate the geometric mean of each row in the count matrix divide each row by the geometric mean for that row take the median value for each column – these are your size factors, one for each sample divide each sample by its size factor Normalized Counts Exercise Determine the normalized counts for your gene of interest, PD1, given the raw counts and size factors below. NOTE: You will need to run the code below to generate the raw counts dataframe (PD1) and the size factor vector (size_factors), then use these objects to determine the normalized counts values: # Raw counts for PD1 PD1 &lt;- c(21, 58, 17, 97, 83, 10) names(PD1) &lt;- paste0(&quot;Sample&quot;, 1:6) PD1 &lt;- data.frame(PD1) PD1 &lt;- t(PD1) # Size factors for each sample size_factors &lt;- c(1.32, 0.70, 1.04, 1.27, 1.11, 0.85) Normalized counts: 9.2.2 Count normalization of Mov10 dataset 9.2.2.1 1. Match the metadata and counts data ### Check that sample names match in both files all(colnames(data) %in% rownames(meta)) ## [1] TRUE all(colnames(data) == rownames(meta)) ## [1] FALSE The colnames of our data don’t match the rownames of our metadata so we need to reorder them. We can use the match function: idx &lt;- match(rownames(meta),colnames(data)) data &lt;- data[,idx] all(colnames(data) == rownames(meta)) ## [1] TRUE Exercise points = +2 Suppose we had sample names matching in the counts matrix and metadata file, but they were out of order. Write the line(s) of code required to create a new matrix with columns ordered such that they were identical to the row names of the metadata. 9.2.2.2 2. Create DESEq2 object ## Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype) ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design ## formula are characters, converting to factors You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use counts(): head(counts(dds[,1:5])) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 ## 1/2-SBSRNA4 45 31 39 57 41 ## A1BG 77 58 40 71 40 ## A1BG-AS1 213 172 126 256 177 ## A1CF 0 0 0 0 1 ## A2LD1 91 80 50 146 81 ## A2M 9 8 4 10 9 colData(dds) ## DataFrame with 8 rows and 2 columns ## sampletype MOVexpr ## &lt;factor&gt; &lt;character&gt; ## Irrel_kd_1 control normal ## Irrel_kd_2 control normal ## Irrel_kd_3 control normal ## Mov10_kd_2 MOV10_knockdown low ## Mov10_kd_3 MOV10_knockdown low ## Mov10_oe_1 MOV10_overexpression high ## Mov10_oe_2 MOV10_overexpression high ## Mov10_oe_3 MOV10_overexpression high colData(dds)$sampletype ## [1] control control control ## [4] MOV10_knockdown MOV10_knockdown MOV10_overexpression ## [7] MOV10_overexpression MOV10_overexpression ## Levels: control MOV10_knockdown MOV10_overexpression levels(colData(dds)$sampletype) ## [1] &quot;control&quot; &quot;MOV10_knockdown&quot; &quot;MOV10_overexpression&quot; As we go through the workflow we will use the relevant functions to check what information gets stored inside our object. We can also run: slotNames(dds) ## [1] &quot;design&quot; &quot;dispersionFunction&quot; &quot;rowRanges&quot; ## [4] &quot;colData&quot; &quot;assays&quot; &quot;NAMES&quot; ## [7] &quot;elementMetadata&quot; &quot;metadata&quot; 9.2.2.3 3. Generate the Mov10 normalized counts The next step is to normalize the count data in order to be able to make fair gene comparisons between samples. To perform the median of ratios method of normalization, DESeq2 has a single estimateSizeFactors() function that will generate size factors for us. We will use the function in the example below, but in a typical RNA-seq analysis this step is automatically performed by the DESeq() function, which we will see later. dds &lt;- estimateSizeFactors(dds) By assigning the results back to the dds object we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factor applied to each sample using: sizeFactors(dds) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 1.1224020 0.9625632 0.7477715 1.5646728 0.9351760 1.2016082 1.1205912 ## Mov10_oe_3 ## 0.6534987 Now, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE. normalized_counts &lt;- counts(dds, normalized=TRUE) We can save this normalized data matrix to file for later use: write.table(normalized_counts, file=&quot;data/normalized_counts.txt&quot;, sep=&quot;\\t&quot;) # it&#39;s always good to save our results, in case we forget to save objects save.image() # saves all objects in session/environment 9.3 DGE QC analysis .md file = 03-DGE_QC_analysis.md The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level steps to perform QC checks on the count data to help us ensure that the samples/replicates look good. 9.3.1 Sample-level QC When using these unsupervised clustering methods, log2-transformation of the normalized counts improves the distances/clustering for visualization. DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering. 9.3.2 Mov10 quality assessment and exploratory analysis 9.3.2.1 Transform normalized counts using the rlog transformation To improve the distances/clustering for the PCA and heirarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts. The rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these tranformed counts downstream: ### Transform counts for data visualization rld &lt;- rlog(dds, blind=TRUE) We use this object to plot the PCA and heirarchical clustering figures for quality assessment. 9.3.2.2 Principal components analysis (PCA) Principal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). The take home message for our purposes is that if two samples have similar levels of expression for the genes that contribute significantly to the variation represented by PC1, they will be plotted close together on the PC1 axis. Therefore, we would expect that biological replicates to have similar scores (since the same genes are changing) and cluster together on PC1 and/or PC2, and the samples from different treatment groups to have different score. This is easiest to understand by visualizing example PCA plots. Exercise points = +8 The figure below was generated from a time course experiment with sample groups ‘Ctrl’ and ‘Sci’ and the following timepoints: 0h, 2h, 8h, and 16h. Determine the sources explaining the variation represented by PC1 and PC2. points = +1 Ans: Do the sample groups separate well? points = +1 Ans: Do the replicates cluster together for each sample group? points = +1 Ans: Are there any outliers in the data? points = +2 Ans: Should we have any other concerns regarding the samples in the dataset? Ans: ### Plot PCA plotPCA(rld, intgroup=&quot;sampletype&quot;) ## using ntop=500 top features by variance What does this plot tell you about the similarity of samples? points = +1 Ans: Does it fit the expectation from the experimental design? points = +1 Ans: By default the function uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot. 9.3.2.3 Hierarchical Clustering Similar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination. We expect to see samples clustered similar to the groupings observed in a PCA plot. We will be using the pheatmap() function from the pheatmap package for heatmaps. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object: ### let&#39;s look at the structure of rld. class(rld) ## [1] &quot;DESeqTransform&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DESeq2&quot; slotNames(rld) ## [1] &quot;rowRanges&quot; &quot;colData&quot; &quot;assays&quot; &quot;NAMES&quot; ## [5] &quot;elementMetadata&quot; &quot;metadata&quot; ### we can extract the rlog matrix from the object using the `assay` function: ### rld_mat &lt;- assay(rld) Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function: ### Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) ## cor() is a base R function head(rld_cor[,1:5]) ## check the output of cor(), make note of the rownames and colnames ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 ## Irrel_kd_1 1.0000000 0.9999614 0.9999532 0.9997202 0.9997748 ## Irrel_kd_2 0.9999614 1.0000000 0.9999544 0.9996918 0.9997568 ## Irrel_kd_3 0.9999532 0.9999544 1.0000000 0.9996816 0.9997574 ## Mov10_kd_2 0.9997202 0.9996918 0.9996816 1.0000000 0.9999492 ## Mov10_kd_3 0.9997748 0.9997568 0.9997574 0.9999492 1.0000000 ## Mov10_oe_1 0.9996700 0.9996984 0.9997067 0.9994868 0.9996154 min(rld_cor) ## we can see our samples are highly correlated ## [1] 0.9993869 And now to plot the correlation values as a heatmap: ### Plot heatmap pheatmap(rld_cor) Exercise The pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot. display.brewer.all() heat.colors &lt;- brewer.pal(9, &quot;Blues&quot;) pheatmap(rld_cor, color = heat.colors, border_color=&quot;black&quot;, fontsize = 10, fontsize_row = 12, show_rownames = T, show_colnames = T) Ans: 9.4 DEG analysis workflow .md file = 04_DGE_DESeq2_analysis.md Differential expression analysis with DESeq2 Differential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Briefly: DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. estimate the gene-wise dispersion estimate the expected dispersion shrink gene-wise dispersion estimates to generate more accurate estimates to model the counts fit the negative binomial model and perform hypothesis testing using the Wald test 9.4.1 Running DESeq2 9.4.1.1 Design formula A design formula tells the statistical software the known sources of variation to control for, as well as, the factor of interest to test for during differential expression testing. For example, let’s look at the design formula for our count matrix: design(dds) ## ~sampletype As another example, suppose you have the following metadata: Exercise points = +5 Suppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were sex and treatment, how would the design formula be written? Based on our Mov10 metadata dataframe, which factors could we include in our design formula? Ans: What would you do if you wanted to include a factor in your design formula that is not in your metadata? Ans: 9.4.1.2 MOV10 DE analysis To get our differential expression results from our raw count data, we only need to run 2 lines of code! ## Create DESeq object dds &lt;- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype) ## Warning in DESeqDataSet(se, design = design, ignoreRank): some variables in design ## formula are characters, converting to factors Then, to run the actual differential expression analysis, we use a single call to the function DESeq(). ## Run analysis dds &lt;- DESeq(dds) ## estimating size factors ## estimating dispersions ## gene-wise dispersion estimates ## mean-dispersion relationship ## final dispersion estimates ## fitting model and testing 9.4.2 DESeq2 differential gene expression analysis workflow Everything from normalization to linear modeling was carried out by the use of a single function! With the 2 lines of code above, we just completed the workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below: 9.4.2.1 Step 1: Estimate size factors MOV10 DE analysis: examining the size factors ## Check the size factors sizeFactors(dds) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 1.1224020 0.9625632 0.7477715 1.5646728 0.9351760 1.2016082 1.1205912 ## Mov10_oe_3 ## 0.6534987 Take a look at the total number of reads for each sample: ## Total number of raw counts per sample colSums(counts(dds, normalized = FALSE)) ## Irrel_kd_1 Irrel_kd_2 Irrel_kd_3 Mov10_kd_2 Mov10_kd_3 Mov10_oe_1 Mov10_oe_2 ## 22687366 19381680 14962754 32826936 19360003 23447317 21713289 ## Mov10_oe_3 ## 12737889 How do the numbers correlate with the size factor? cor(colSums(counts(dds, normalized = FALSE)),sizeFactors(dds)) ## [1] 0.9946543 Ans: they are highly correlated 9.4.2.2 Step 2: Estimate gene-wise dispersion** Dispersion is a measure of spread or variability in the data. DESeq2 uses a specific measure of dispersion (α) related to the mean (μ) and variance of the data: \\(Var = μ + α*μ^2\\). For genes with moderate to high count values, the square root of dispersion will be equal to the coefficient of variation (σ/ μ). So 0.01 dispersion means 10% variation around the mean expected across biological replicates. We can make a rough estimate of the gene-wise dispersions using this formula. We know that: \\[\\sigma^2 = {\\mu + \\alpha*}{\\mu^2}\\] So the dispersion is equal to: \\[\\alpha = \\frac{\\sigma^2 - \\mu}{\\mu^2}\\] norm.cts &lt;- counts(dds,normalized = TRUE) mn &lt;- rowMeans(norm.cts) mn=mn[order(mn)] mn &lt;- mn[mn!=0] v &lt;- rowVars(norm.cts) names(v) = rownames(norm.cts) v = v[names(mn)] # For genes with moderate to high count values, the square root of dispersion will be equal to the coefficient of variation (`σ / μ`). # Let&#39;s try a relatively low mean # to calculate the dispersion, v has to be greater than mu otherwise the disp will be negative wv = which(v &gt; mn) var &lt;- v[wv][1] mu &lt;- mn[wv][1] disp &lt;- (var - mu)/mu^2 sqrt(var)/mu ## ACY3 ## 2.828427 sqrt(disp) ## ACY3 ## 0.5472605 So the approximation doesn’t work very well here. Now let’s try a high mean: var &lt;- v[wv][length(wv)] mu &lt;- mn[wv][length(wv)] disp &lt;- (var - mu)/mu^2 # approximation for the square root of the dispersion sqrt(var)/mu ## EEF2 ## 0.08296104 # actual sqrt disp sqrt(disp) ## EEF2 ## 0.08288016 Now the approximation is pretty good. The larger the value of the mean, the better the approximation. What does the DESeq2 dispersion represent? The DESeq2 dispersion estimates are inversely related to the mean and directly related to variance. Based on this relationship, the dispersion is higher for small mean counts and lower for large mean counts. How does the dispersion relate to our model? To accurately model sequencing counts, we need to generate accurate estimates of within-group variation (variation between replicates of the same sample group) for each gene. With only a few (3-6) replicates per group, the estimates of variation for each gene are often unreliable (due to the large differences in dispersion for genes with similar means). To address this problem, DESeq2 shares information across genes to generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels have similar dispersion. Estimating the dispersion for each gene separately: To model the dispersion based on expression level (mean counts of replicates), the dispersion for each gene is estimated using maximum likelihood estimation. In statistics, maximum likelihood estimation (MLE) is a method of estimating the parameters of an assumed probability distribution, given some observed data. This is achieved by maximizing a likelihood function so that, under the assumed statistical model, the observed data is most probable. In other words, given the count values of the replicates, the most likely estimate of dispersion is calculated. 9.4.2.3 Step 3: Fit curve to gene-wise dispersion estimates The next step in the workflow is to fit a curve to the dispersion estimates for each gene. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability, but, over all genes, there will be a distribution of reasonable estimates of dispersion. 9.4.2.4 Step 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve The curve allows for more accurate identification of differentially expressed genes when sample sizes are small, and the strength of the shrinkage for each gene depends on: how close gene dispersions are from the curve sample size (more samples = less shrinkage) Dispersion plots are a good way to examine your data to ensure it is a good fit for the DESeq2 model. 9.4.2.4.1 MOV10 DE analysis: exploring the dispersion estimates and assessing model Let’s take a look at the dispersion estimates for our MOV10 data: ## Plot dispersion estimates plotDispEsts(dds) Since we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model? Ans: Yes 9.5 Model fitting .md file = 05_DGE_DESeq2_analysis2 9.5.1 Generalized Linear Model fit for each gene The final step in the DESeq2 workflow is fitting the Negative Binomial model for each gene and performing differential expression testing. 9.5.2 Shrunken log2 foldchanges (LFC) To generate more accurate log2 foldchange estimates, DESeq2 allows for the shrinkage of the LFC estimates toward zero when the information for a gene is low, which could include: Low counts High dispersion values As with the shrinkage of dispersion estimates, LFC shrinkage uses information from all genes to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates. 9.5.3 Hypothesis testing using the Wald test With DESeq2, the Wald test is commonly used for hypothesis testing when comparing two groups. A Wald test statistic is computed along with a probability that a test statistic at least as extreme as the observed value were selected at random. This probability is called the p-value of the test. If the p-value is small we reject the null hypothesis and state that there is evidence against the null (i.e. the gene is differentially expressed). 9.5.3.1 Creating contrasts To indicate to DESeq2 the two groups we want to compare, we can use contrasts. Contrasts are then provided to DESeq2 to perform differential expression testing using the Wald test. Contrasts can be provided to DESeq2 a couple of different ways: Do nothing. Automatically DESeq2 will use the base factor level of the condition of interest as the base for statistical testing. The base level is chosen based on alphabetical order of the levels. In the results() function you can specify the comparison of interest, and the levels to compare. The level given last is the base level for the comparison. The syntax is given below: # DO NOT RUN! contrast &lt;- c(&quot;condition&quot;, &quot;level_to_compare&quot;, &quot;base_level&quot;) results(dds, contrast = contrast, alpha = alpha_threshold) 9.5.3.1.1 MOV10 DE analysis: contrasts and Wald tests We have three sample classes so we can make three possible pairwise comparisons: Control vs. Mov10 overexpression Control vs. Mov10 knockdown Mov10 knockdown vs. Mov10 overexpression We are really only interested in #1 and #2 from above. Using the design formula we provided ~ sampletype, indicating that this is our main factor of interest. 9.5.3.2 Building the results table ## Define contrasts, extract results table, and shrink the log2 fold changes contrast_oe &lt;- c(&quot;sampletype&quot;, &quot;MOV10_overexpression&quot;, &quot;control&quot;) res_tableOE_unshrunken &lt;- results(object = dds, contrast=contrast_oe, alpha = 0.05) # for the coef argument of lfcShrink we have to use coefficient names from the `resultsNames()` resultsNames(dds) ## [1] &quot;Intercept&quot; ## [2] &quot;sampletype_MOV10_knockdown_vs_control&quot; ## [3] &quot;sampletype_MOV10_overexpression_vs_control&quot; res_tableOE &lt;- lfcShrink(dds, coef = &quot;sampletype_MOV10_overexpression_vs_control&quot;, res = res_tableOE_unshrunken, type = &quot;apeglm&quot;) ## using &#39;apeglm&#39; for LFC shrinkage. If used in published research, please cite: ## Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for ## sequence count data: removing the noise and preserving large differences. ## Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895 # We will save these results for later use in the data directory using the following command: saveRDS(res_tableOE, file = &quot;data/res_tableOE.rds&quot;) The order of the names determines the direction of fold change that is reported. The name provided in the second element is the level that is used as baseline. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in Mov10_oe relative to the control. 9.5.3.3 MA Plot A plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 fold changes for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot. Let’s start with the unshrunken results: Viewing the results: par(mfrow = c(1,2)) plotMA(res_tableOE_unshrunken, ylim=c(-2,2)) And now the shrunken results: plotMA(res_tableOE, ylim=c(-2,2)) par(mfrow = c(1,1)) This plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression. 9.5.3.3.1 MOV10 DE analysis: results exploration The results table looks very much like a dataframe and in many ways it can be treated like one (i.e when accessing/subsetting data). However, it is important to recognize that it is actually stored in a DESeqResults object. When we start visualizing our data, this information will be helpful. class(res_tableOE) ## [1] &quot;DESeqResults&quot; ## attr(,&quot;package&quot;) ## [1] &quot;DESeq2&quot; Let’s go through some of the columns in the results table to get a better idea of what we are looking at. To extract information regarding the meaning of each column we can use mcols(): mcols(res_tableOE, use.names=T) ## DataFrame with 5 rows and 2 columns ## type description ## &lt;character&gt; &lt;character&gt; ## baseMean intermediate mean of normalized c.. ## log2FoldChange results log2 fold change (MA.. ## lfcSE results posterior SD: sample.. ## pvalue results Wald test p-value: s.. ## padj results BH adjusted p-values mcols(res_tableOE, use.names=T)$description ## [1] &quot;mean of normalized counts for all samples&quot; ## [2] &quot;log2 fold change (MAP): sampletype MOV10_overexpression vs control&quot; ## [3] &quot;posterior SD: sampletype MOV10 overexpression vs control&quot; ## [4] &quot;Wald test p-value: sampletype MOV10 overexpression vs control&quot; ## [5] &quot;BH adjusted p-values&quot; res_tableOE %&gt;% data.frame() %&gt;% head() baseMean log2FoldChange lfcSE pvalue padj 1/2-SBSRNA4 45.6520399 0.1682023 0.2091004 0.1610752 0.2655661 A1BG 61.0931017 0.1364590 0.1767790 0.2401909 0.3603094 A1BG-AS1 175.6658069 -0.0404612 0.1169284 0.6789312 0.7748342 A1CF 0.2376919 0.0062675 0.2100570 0.7945932 NA A2LD1 89.6179845 0.2901772 0.1953954 0.0333343 0.0741149 A2M 5.8600841 -0.0961972 0.2335610 0.1057823 0.1900466 If we used the p-value directly from the Wald test with a significance cut-off of p &lt; 0.05, that means there is a 5% chance it is a false positives. Each p-value is the result of a single test (single gene). The more genes we test, the more we inflate the false positive rate. This is the multiple testing problem. In DESeq2, the p-values attained by the Wald test are corrected for multiple testing using the Benjamini and Hochberg method by default. There are options to use other methods in the results() function. The p-adjusted values should be used to determine significant genes. 9.5.3.3.2 MOV10 DE analysis: Control versus Knockdown Now that we have results for the overexpression results, let’s do the same for the Control vs. Knockdown samples. Use contrasts in the results() to extract a results table and store that to a variable called res_tableKD. ## Define contrasts, extract results table and shrink log2 fold changes contrast_kd &lt;- c(&quot;sampletype&quot;, &quot;MOV10_knockdown&quot;, &quot;control&quot;) res_tableKD_unshrunken &lt;- results(object = dds, contrast=contrast_kd, alpha = 0.05) # for the coef argument in &#39;lfcShrink&#39; you can also provide a number based on the order in `resultsNames()` resultsNames(dds) ## [1] &quot;Intercept&quot; ## [2] &quot;sampletype_MOV10_knockdown_vs_control&quot; ## [3] &quot;sampletype_MOV10_overexpression_vs_control&quot; res_tableKD &lt;- lfcShrink(dds, coef = 2, res=res_tableKD_unshrunken) ## using &#39;apeglm&#39; for LFC shrinkage. If used in published research, please cite: ## Zhu, A., Ibrahim, J.G., Love, M.I. (2018) Heavy-tailed prior distributions for ## sequence count data: removing the noise and preserving large differences. ## Bioinformatics. https://doi.org/10.1093/bioinformatics/bty895 # We will save these results for later use in the data directory using the following command: saveRDS(res_tableKD, file = &quot;data/res_tableKD.rds&quot;) # just for security, save all our objects in &quot;.RData&quot; again: save.image() Let’s look at the number of genes below the standard p-adjusted value 0.05: table(res_tableKD$padj &lt; 0.05) ## ## FALSE TRUE ## 10668 4909 table(res_tableOE$padj &lt; 0.05) ## ## FALSE TRUE ## 9066 6511 9.5.4 Summarizing results To summarize the results table, a handy function in DESeq2 is summary(). Confusingly it has the same name as the function used to inspect data frames. This function when called with a DESeq results table as input, will summarize the results using the alpha threshold: FDR &lt; 0.05 (padj/FDR is used even though the output says p-value &lt; 0.05). summary(res_tableOE) ## ## out of 19748 with nonzero total read count ## adjusted p-value &lt; 0.05 ## LFC &gt; 0 (up) : 3103, 16% ## LFC &lt; 0 (down) : 3408, 17% ## outliers [1] : 0, 0% ## low counts [2] : 4171, 21% ## (mean count &lt; 5) ## [1] see &#39;cooksCutoff&#39; argument of ?results ## [2] see &#39;independentFiltering&#39; argument of ?results 9.5.4.1 Extracting significant differentially expressed genes What we noticed is that the FDR threshold on it’s own doesn’t appear to be reducing the number of significant genes. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also add a fold change threshold. ### Set thresholds padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 ## change in expression of 1.5 The lfc.cutoff is set to 0.58; remember that we are working with log2 fold changes so this translates to an actual fold change of 1.5 which is pretty reasonable. We can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble: res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() Now we can subset that table to only keep the significant genes using our pre-defined thresholds: sigOE &lt;- res_tableOE_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) Exercise How many genes are differentially expressed in the Overexpression compared to Control, given our criteria specified above? Does this reduce our results? points = +2 Ans: Does this reduce our results? -Ans: Using the same thresholds as above (padj.cutoff &lt; 0.05 and lfc.cutoff = 0.58), subset res_tableKD to report the number of genes that are up- and down-regulated in Mov10_knockdown compared to control. res_tableKD_tb &lt;- res_tableKD %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() sigKD &lt;- res_tableKD_tb %&gt;% dplyr::filter(padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) # We&#39;ll save this object for use in the homework saveRDS(sigKD,&quot;data/sigKD.rds&quot;) Exercise How many genes are differentially expressed in the Knockdown compared to Control? Ans: 9.6 Visualizing rna-seq results .md file = 06_DGE_visualizing_results.md Let’s start by loading a few libraries (if not already loaded): # load libraries library(tidyverse) library(ggplot2) library(ggrepel) library(RColorBrewer) library(DESeq2) library(pheatmap) # we may want to load our objects again. here: # load(&quot;.RData&quot;) When we are working with large amounts of data it can be useful to display that information graphically to gain more insight. Let’s create tibble objects from the meta and normalized_counts data frames before we start plotting. This will enable us to use the tidyverse functionality more easily. Basically, we are taking the rownames and adding them as a field in the tibble/data.frame. # Create a tibble for meta data mov10_meta &lt;- meta %&gt;% rownames_to_column(var=&quot;samplename&quot;) %&gt;% as_tibble() # you might to read in normalized_counts if it is not in your current session: # normalized_counts &lt;- read.delim(&quot;data/normalized_counts.txt&quot;, row.names=1) # then make sure the colnames of normalized_counts are the same as the mov10_meta$sampname all(mov10_meta$samplename == colnames(normalized_counts)) ## [1] TRUE # if they aren&#39;t we need to reorder them # mtch = match(mov10_meta$samplename, colnames(normalized_counts)) # # normalized_counts &lt;- normalized_counts[,mtch] # # all(mov10_meta$samplename == colnames(normalized_counts)) # Create a tibble for normalized_counts normalized_counts &lt;- normalized_counts %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% as_tibble() 9.6.1 Plotting signicant DE genes One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes. 9.6.1.1 Using DESeq2 plotCounts() to plot expression of a single gene To pick out a specific gene of interest to plot, for example Mov10, we can use the plotCounts() from DESeq2: # Plot expression for single gene plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;) # we can give it some color and filled points: sampletype = as.factor(mov10_meta$sampletype) library(RColorBrewer) display.brewer.all() col = brewer.pal(8,&quot;Dark2&quot;) palette(col) plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;,col = as.numeric(sampletype),pch = 19) 9.6.1.2 Using ggplot2 to plot expression of a single gene If you wish to change the appearance of this plot, we can save the output of plotCounts() to a variable specifying the returnData=TRUE argument, then use ggplot(): # Save plotcounts to a data frame object d &lt;- plotCounts(dds, gene=&quot;MOV10&quot;, intgroup=&quot;sampletype&quot;, returnData=TRUE) # Plotting the MOV10 normalized counts, using the samplenames (rownames of d as labels) ggplot(d, aes(x = sampletype, y = count, color = sampletype)) + geom_point(position=position_jitter(w = 0.1,h = 0)) + geom_text_repel(aes(label = rownames(d))) + theme_bw() + ggtitle(&quot;MOV10&quot;) + theme(plot.title = element_text(hjust = 0.5)) 9.6.1.3 Using ggplot2 to plot multiple genes (e.g. top 20) Often it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling. We are going to plot the normalized count values for the top 20 differentially expressed genes (by padj values). ## Order results by padj values top20_sigOE_genes &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% #Arrange rows by padj values pull(gene) %&gt;% #Extract character vector of ordered genes head(n=20) #Extract the first 20 genes Then, we can extract the normalized count values for these top 20 genes: ## normalized counts for top 20 significant genes top20_sigOE_norm &lt;- normalized_counts %&gt;% dplyr::filter(gene %in% top20_sigOE_genes) Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to pivot_longer top20_sigOE_norm from a wide format to a long format so the counts for all samples will be in a single column to allow us to give ggplot the one column with the values we want it to plot. The pivot_longer() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth. # Pivoting the columns to have normalized counts to a single column pivoted_top20_sigOE &lt;- top20_sigOE_norm %&gt;% pivot_longer(colnames(top20_sigOE_norm)[2:9], names_to = &quot;samplename&quot;, values_to = &quot;normalized_counts&quot;) ## check the column header in the &quot;pivoted&quot; data frame head(pivoted_top20_sigOE) gene samplename normalized_counts ADAMTS1 Irrel_kd_1 6717.735 ADAMTS1 Irrel_kd_2 6454.641 ADAMTS1 Irrel_kd_3 6801.543 ADAMTS1 Mov10_kd_2 6869.168 ADAMTS1 Mov10_kd_3 8730.977 ADAMTS1 Mov10_oe_1 13252.239 Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to ggplot(): # `inner_join(x,y)` will merge 2 data frames by the colname in x that matches a column name in y. # it is similar to doing a match(pivoted_top20_sigOE$samplename, mov10_meta$samplename) and then adding sampletype and MOV10exr to pivoted_top20_sigOE, but it is more efficient because the columns from mov10_meta are added in a single command. pivoted_top20_sigOE &lt;- inner_join(mov10_meta, pivoted_top20_sigOE, by = &quot;samplename&quot;) Now that we have a data frame in a format that can be utilized by ggplot easily, let’s plot! ## plot using ggplot2 ggplot(pivoted_top20_sigOE) + geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) + scale_y_log10() + xlab(&quot;Genes&quot;) + ylab(&quot;log10 Normalized Counts&quot;) + ggtitle(&quot;Top 20 Significant DE Genes&quot;) + theme_bw() + theme(axis.text.x = element_text(angle = 45, hjust = 1)) + theme(plot.title = element_text(hjust = 0.5)) 9.6.2 Heatmap In addition to plotting subsets, we could also extract the normalized values of all the significant genes and plot a heatmap of their expression using pheatmap(). ### Extract normalized expression for significant genes from the OE and control samples c(2:4,7:9), and set the gene column (1) to row names norm_OEsig &lt;- normalized_counts[,c(1,2:4,7:9)] %&gt;% filter(gene %in% sigOE$gene) %&gt;% data.frame() %&gt;% column_to_rownames(var = &quot;gene&quot;) Now let’s draw the heatmap using pheatmap: ### Annotate our heatmap (optional) annotation &lt;- mov10_meta %&gt;% dplyr::select(samplename, sampletype) %&gt;% data.frame(row.names = &quot;samplename&quot;) ### Set a color palette heat_colors &lt;- brewer.pal(6, &quot;YlOrRd&quot;) ### Run pheatmap pheatmap(norm_OEsig, color = heat_colors, cluster_rows = T, show_rownames = F, annotation = annotation, border_color = NA, fontsize = 10, scale = &quot;row&quot;, fontsize_row = 10, height = 20) 9.6.2.1 Volcano plot The above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis. To generate a volcano plot (which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis), we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values. ## Obtain logical vector where TRUE values denote padj values &lt; 0.05 and fold change &gt; 1.5 in either direction res_tableOE_tb &lt;- res_tableOE_tb %&gt;% mutate(threshold_OE = padj &lt; 0.05 &amp; abs(log2FoldChange) &gt;= 0.58) Now we can start plotting: ## Volcano plot ggplot(res_tableOE_tb) + geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold_OE)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + #scale_y_continuous(limits = c(0,50)) + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) ## Warning: Removed 7791 rows containing missing values or values outside the scale range ## (`geom_point()`). What if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using geom_text_repel(). First, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot. ## Create a column to indicate which genes to label res_tableOE_tb &lt;- res_tableOE_tb %&gt;% arrange(padj) %&gt;% mutate(genelabels = &quot;&quot;) res_tableOE_tb$genelabels[1:10] &lt;- res_tableOE_tb$gene[1:10] head(res_tableOE_tb) gene baseMean log2FoldChange lfcSE pvalue padj threshold_OE genelabels MOV10 21681.800 5.0796303 0.1101145 0 0 TRUE MOV10 H1F0 7881.081 1.5517867 0.0565777 0 0 TRUE H1F0 HIST1H1C 1741.383 1.5233152 0.0706090 0 0 TRUE HIST1H1C TXNIP 5133.749 1.4193814 0.0696576 0 0 TRUE TXNIP NEAT1 21973.706 0.9162823 0.0466942 0 0 TRUE NEAT1 KLF10 1694.211 1.2332114 0.0651896 0 0 TRUE KLF10 Next, we plot it as before with an additional layer for geom_text_repel() wherein we can specify the column of gene labels we just created. ggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) + geom_point(aes(colour = threshold_OE)) + geom_text_repel(aes(label = genelabels)) + ggtitle(&quot;Mov10 overexpression&quot;) + xlab(&quot;log2 fold change&quot;) + ylab(&quot;-log10 adjusted p-value&quot;) + theme(legend.position = &quot;none&quot;, plot.title = element_text(size = rel(1.5), hjust = 0.5), axis.title = element_text(size = rel(1.25))) ## Warning: Removed 7791 rows containing missing values or values outside the scale range ## (`geom_point()`). ## Warning: Removed 7791 rows containing missing values or values outside the scale range ## (`geom_text_repel()`). 9.7 Summary of differential expression analysis workflow .md file = 07-DGE_summarizing_workflow.md ## Setup ### Bioconductor and CRAN libraries used library(DESeq2) We have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below: 9.7.1 1. Import data into dds object: # Check that the row names of the metadata equal the column names of the **raw counts** data all(colnames(raw_counts) == rownames(metadata)) # Create DESeq2Dataset object dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition) 9.7.2 2. Exploratory data analysis (PCA &amp; heirarchical clustering) - identifying outliers and sources of variation in the data: # Transform counts for data visualization rld &lt;- rlog(dds, blind=TRUE) # Plot PCA plotPCA(rld, intgroup=&quot;sampletype&quot;) # Extract the rlog matrix from the object rld_mat &lt;- assay(rld) # Compute pairwise correlation values rld_cor &lt;- cor(rld_mat) # Plot heatmap pheatmap(rld_cor) 9.7.3 3. Run DESeq2: # **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation dds &lt;- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition) # Run DESeq2 differential expression analysis dds &lt;- DESeq(dds) # **Optional step** - Output normalized counts to save as a file to access outside RStudio normalized_counts &lt;- counts(dds, normalized=TRUE) write.table(normalized_counts, file=&quot;data/normalized_counts.txt&quot;, sep=&quot;\\t&quot;, quote=F, col.names=NA) 9.7.4 4. Check the fit of the dispersion estimates: # Plot dispersion estimates plotDispEsts(dds) 9.7.5 5. Create contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions: # Output results of Wald test for contrast contrast &lt;- c(&quot;condition&quot;, &quot;level_to_compare&quot;, &quot;base_level&quot;) res &lt;- results(dds, contrast = contrast) coef = resultsNames(dds) res_tableOE &lt;- lfcShrink(dds, coef = coef[?], res=res, type = &quot;apeglm&quot;) 9.7.6 6. Output significant results: ### Set thresholds padj.cutoff &lt;- 0.05 lfc.cutoff &lt;- 0.58 ## change in expression of 1.5 # Turn the results object into a data frame res_df &lt;- res %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) # Subset the significant results sig_res &lt;- dplyr::filter(res_df, padj &lt; padj.cutoff &amp; abs(log2FoldChange) &gt; lfc.cutoff) 9.7.7 7. Visualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc. 9.7.8 8. Make sure to output the versions of all tools used in the DE analysis: sessionInfo() ## R version 4.4.1 (2024-06-14) ## Platform: x86_64-apple-darwin20 ## Running under: macOS Sonoma 14.6.1 ## ## Matrix products: default ## BLAS: /System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/Versions/A/libBLAS.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/4.4-x86_64/Resources/lib/libRlapack.dylib; LAPACK version 3.12.0 ## ## locale: ## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 ## ## time zone: America/Vancouver ## tzcode source: internal ## ## attached base packages: ## [1] stats4 stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] ggrepel_0.9.5 pheatmap_1.0.12 ## [3] RColorBrewer_1.1-3 GOenrichment_0.5.0 ## [5] igraph_2.0.3 DESeq2_1.44.0 ## [7] SummarizedExperiment_1.34.0 MatrixGenerics_1.16.0 ## [9] matrixStats_1.3.0 GenomicRanges_1.56.1 ## [11] GenomeInfoDb_1.40.1 fgsea_1.30.0 ## [13] enrichplot_1.24.2 lubridate_1.9.3 ## [15] forcats_1.0.0 stringr_1.5.1 ## [17] dplyr_1.1.4 purrr_1.0.2 ## [19] readr_2.1.5 tidyr_1.3.1 ## [21] tibble_3.2.1 ggplot2_3.5.1 ## [23] tidyverse_2.0.0 clusterProfiler_4.12.3 ## [25] org.Hs.eg.db_3.19.1 AnnotationDbi_1.66.0 ## [27] IRanges_2.38.1 S4Vectors_0.42.1 ## [29] Biobase_2.64.0 BiocGenerics_0.50.0 ## [31] bookdown_0.40 ## ## loaded via a namespace (and not attached): ## [1] rstudioapi_0.16.0 jsonlite_1.8.8 magrittr_2.0.3 ## [4] farver_2.1.2 rmarkdown_2.28 fs_1.6.4 ## [7] zlibbioc_1.50.0 vctrs_0.6.5 memoise_2.0.1 ## [10] ggtree_3.12.0 S4Arrays_1.4.1 htmltools_0.5.8.1 ## [13] SparseArray_1.4.8 gridGraphics_0.5-1 sass_0.4.9 ## [16] bslib_0.8.0 htmlwidgets_1.6.4 plyr_1.8.9 ## [19] httr2_1.0.2 cachem_1.1.0 lifecycle_1.0.4 ## [22] pkgconfig_2.0.3 Matrix_1.7-0 R6_2.5.1 ## [25] fastmap_1.2.0 gson_0.1.0 GenomeInfoDbData_1.2.12 ## [28] numDeriv_2016.8-1.1 digest_0.6.37 aplot_0.2.3 ## [31] ggnewscale_0.5.0 colorspace_2.1-1 patchwork_1.2.0 ## [34] RSQLite_2.3.7 labeling_0.4.3 fansi_1.0.6 ## [37] timechange_0.3.0 abind_1.4-5 httr_1.4.7 ## [40] polyclip_1.10-7 compiler_4.4.1 bit64_4.0.5 ## [43] withr_3.0.1 BiocParallel_1.38.0 viridis_0.6.5 ## [46] DBI_1.2.3 highr_0.11 ggforce_0.4.2 ## [49] MASS_7.3-61 DelayedArray_0.30.1 rappdirs_0.3.3 ## [52] HDO.db_0.99.1 tools_4.4.1 ape_5.8 ## [55] scatterpie_0.2.3 glue_1.7.0 nlme_3.1-166 ## [58] GOSemSim_2.30.1 rsconnect_1.3.1 grid_4.4.1 ## [61] shadowtext_0.1.4 reshape2_1.4.4 generics_0.1.3 ## [64] gtable_0.3.5 tzdb_0.4.0 data.table_1.15.4 ## [67] hms_1.1.3 tidygraph_1.3.1 utf8_1.2.4 ## [70] XVector_0.44.0 pillar_1.9.0 emdbook_1.3.13 ## [73] yulab.utils_0.1.6 splines_4.4.1 tweenr_2.0.3 ## [76] treeio_1.28.0 lattice_0.22-6 bit_4.0.5 ## [79] tidyselect_1.2.1 locfit_1.5-9.10 GO.db_3.19.1 ## [82] Biostrings_2.72.1 knitr_1.48 gridExtra_2.3 ## [85] xfun_0.47 graphlayouts_1.1.1 visNetwork_2.1.2 ## [88] stringi_1.8.4 UCSC.utils_1.0.0 lazyeval_0.2.2 ## [91] ggfun_0.1.5 yaml_2.3.10 evaluate_0.24.0 ## [94] codetools_0.2-20 bbmle_1.0.25.1 ggraph_2.2.1 ## [97] qvalue_2.36.0 ggplotify_0.1.2 cli_3.6.3 ## [100] munsell_0.5.1 jquerylib_0.1.4 Rcpp_1.0.13 ## [103] coda_0.19-4.1 png_0.1-8 bdsmatrix_1.3-7 ## [106] parallel_4.4.1 blob_1.2.4 DOSE_3.30.2 ## [109] mvtnorm_1.2-6 apeglm_1.26.1 viridisLite_0.4.2 ## [112] tidytree_0.4.6 scales_1.3.0 crayon_1.5.3 ## [115] rlang_1.1.4 cowplot_1.1.3 fastmatch_1.1-4 ## [118] KEGGREST_1.44.1 Exercise/Homework: modify this file to analyze the MOV dataset. Include a heatmap and a volcano plot 9.8 Functional analysis of RNA-seq data .md file = 08-GO_enrichment_analysis.md Functional analysis tools are useful in interpreting resulting DGE gene lists from RNAseq, and fall into three main types: Over-representation analysis Functional class scoring Pathway topology 9.8.1 Over-representation analysis To determine whether any GO terms are over-represented in a significant gene list, the probability of the observed proportion of genes associated with a specific term is compared to the probability of the background set of genes belonging to the same term. This statistical test is known as the “hypergeometric test”. We will be using clusterProfiler 9.8.2 clusterProfiler # you may have to install some of these libraries; use # BiocManager::install(c(&quot;org.Hs.eg.db&quot;,&quot;clusterProfiler&quot;,&quot;enrichplot&quot;,&quot;fgsea&quot;)) library(org.Hs.eg.db) library(clusterProfiler) library(tidyverse) library(enrichplot) library(fgsea) 9.8.2.1 Running clusterProfiler res_tableOE = readRDS(&quot;data/res_tableOE.rds&quot;) res_tableOE_tb &lt;- res_tableOE %&gt;% data.frame() %&gt;% rownames_to_column(var=&quot;gene&quot;) %&gt;% dplyr::filter(!is.na(log2FoldChange)) %&gt;% as_tibble() To perform the over-representation analysis, we need a list of background genes and a list of significant genes. For our background dataset we will use all genes tested for differential expression (all genes in our results table). For our significant gene list we will use genes with p-adjusted values less than 0.05 (we could include a fold change threshold too if we have many DE genes). ## background set of ensgenes allOE_genes &lt;- res_tableOE_tb$gene sigOE = dplyr::filter(res_tableOE_tb, padj &lt; 0.05) sigOE_genes = sigOE$gene Now we can perform the GO enrichment analysis and save the results: ## Run GO enrichment analysis ego &lt;- enrichGO(gene = sigOE_genes, universe = allOE_genes, keyType = &quot;SYMBOL&quot;, OrgDb = org.Hs.eg.db, minGSSize = 20, maxGSSize = 300, ont = &quot;BP&quot;, pAdjustMethod = &quot;BH&quot;, qvalueCutoff = 0.05, readable = TRUE) ## Output results from GO analysis to a table cluster_summary &lt;- data.frame(ego) ## make sure you have a results directory write.csv(cluster_summary, &quot;results/clusterProfiler_Mov10oe.csv&quot;) 9.8.2.2 Visualizing clusterProfiler results dotplot The dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 50 genes by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value. ## Dotplot ## dotplot(ego, showCategory=50) To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF….set PDF size to 8 x 14 to give a figure of appropriate size for the text labels enrichment GO plot The next plot is the enrichment GO plot, which shows the relationship between the top 50 most significantly enriched GO terms (padj.), by grouping similar terms together. The color represents the p-values relative to the other displayed terms (brighter red is more significant) and the size of the terms represents the number of genes that are significant from our list. This plot is useful because it serves to collapse the GO terms into functional categories by showing the overlap between GO terms. ## Enrichmap clusters the 50 most significant (by padj) GO terms to visualize relationships between terms pwt &lt;- pairwise_termsim( ego, method = &quot;JC&quot;, semData = NULL, showCategory = 50 ) emapplot(pwt, showCategory = 50) ## Warning: ggrepel: 10 unlabeled data points (too many overlaps). Consider increasing ## max.overlaps To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF…. In the pop-up window, change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels. Finally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the pvalues of the terms, with the more significant terms being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes. netplot ## To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector OE_foldchanges &lt;- sigOE$log2FoldChange names(OE_foldchanges) &lt;- sigOE$gene ## Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj) cnetplot(ego, categorySize=&quot;pvalue&quot;, showCategory = 5, foldChange = OE_foldchanges, vertex.label.font=6) ## Warning in cnetplot.enrichResult(x, ...): Use &#39;color.params = list(foldChange = your_value)&#39; instead of &#39;foldChange&#39;. ## The foldChange parameter will be removed in the next version. ## Warning: ggrepel: 436 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps Again, to save the figure, click on the Export button in the RStudio Plots tab and Save as PDF…. Change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels. 9.8.3 Gene set enrichment analysis (GSEA) 9.8.3.1 GSEA using clusterProfiler GSEA uses the entire list of log2 fold changes from all genes. It is based on looking for enrichment of genesets among the large positive or negative fold changes. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. Extract and name the fold changes: ## Extract the foldchanges foldchanges &lt;- res_tableOE_tb$log2FoldChange ## Name each fold change with the corresponding Entrez ID names(foldchanges) &lt;- res_tableOE_tb$gene Next we need to order the fold changes in decreasing order. To do this we’ll use the sort() function, which takes a vector as input. This is in contrast to Tidyverse’s arrange(), which requires a data frame. ## Sort fold changes in decreasing order foldchanges &lt;- sort(foldchanges, decreasing = TRUE) head(foldchanges) ## HSPA6 MOV10 ASCL1 HSPA7 SCRT1 SIGLEC14 ## 6.246267 5.079630 4.441203 3.637040 2.925440 2.615129 We can explore the enrichment of BP Gene Ontology terms using gene set enrichment analysis: # GSEA using gene sets associated with BP Gene Ontology terms gseaGO &lt;- clusterProfiler::gseGO( geneList = foldchanges, ont = &quot;BP&quot;, keyType = &quot;SYMBOL&quot;, eps = 0, minGSSize = 20, maxGSSize = 300, pAdjustMethod = &quot;BH&quot;, pvalueCutoff = 0.05, verbose = TRUE, OrgDb = &quot;org.Hs.eg.db&quot;, by = &quot;fgsea&quot; ) ## using &#39;fgsea&#39; for GSEA analysis, please cite Korotkevich et al (2019). ## preparing geneSet collections... ## GSEA analysis... ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (8.07% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. ## leading edge analysis... ## done... gseaGO_results &lt;- gseaGO@result goplot(gseaGO) # default is 10 categories ## Warning: ggrepel: 84 unlabeled data points (too many overlaps). Consider increasing ## max.overlaps gseaplot2(gseaGO, geneSetID = 1:3) We can also use our homemade GO enrichment analysis. To do this we need to load the library GOenrichment: # Uncomment the following if you haven&#39;t yet installed GOenrichment. # devtools::install_github(&quot;gurinina/GOenrichment&quot;) library(GOenrichment) ls(&quot;package:GOenrichment&quot;) ## [1] &quot;compSCORE&quot; &quot;dfGOBP&quot; &quot;hGOBP.gmt&quot; &quot;hyperG&quot; &quot;runGORESP&quot; ## [6] &quot;runNetwork&quot; &quot;sampleFitdata&quot; &quot;visSetup&quot; &quot;yGOBP.gmt&quot; One of the problems with GO enrichment analysis is that the GO annotations are in constant flux. Here we can use the GO annotations in hGOBP.gmt (downloaded recently) to run GSEA using the fgsea package to run GSEA: fgseaRes &lt;- fgsea::fgseaSimple(pathways = hGOBP.gmt,stats=foldchanges,nperm=1000,maxSize = 300,minSize = 20) ## Warning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (8.07% of the list). ## The order of those tied genes will be arbitrary, which may produce unexpected results. fgsea &lt;- data.frame(fgseaRes,stringsAsFactors = F) w = which(fgsea$ES &gt; 0) fposgsea &lt;- fgsea[w,] fposgsea &lt;- fposgsea %&gt;% arrange(padj) We are going to compare these results to runing the GO enrichment function runGORESP. runGORESP uses over-representation analysis to identify enriched GO terms, so we need to define a significance cutoff for the querySet. args(runGORESP) ## function (mat, coln, curr_exp = colnames(mat)[coln], sig = 1, ## fdrThresh = 0.2, bp_path = NULL, bp_input = NULL, go_path = NULL, ## go_input = NULL, minSetSize = 5, maxSetSize = 300) ## NULL ?runGORESP # we&#39;ll define our significance cutoff as 0.58, corresponding to 1.5x change. # `runGORESP` requires a matrix, so we can turn foldchanges into a matrix using `cbind`: matx &lt;- cbind(foldchanges,foldchanges) hresp = GOenrichment::runGORESP(fdrThresh = 0.2,mat=matx, coln=1,curr_exp = colnames(matx)[1], sig = 0.58, bp_input = hGOBP.gmt,go_input = NULL,minSetSize = 20, maxSetSize = 300) names(hresp$edgeMat) ## [1] &quot;source&quot; &quot;target&quot; &quot;overlapCoeff&quot; &quot;width&quot; &quot;label&quot; names(hresp$enrichInfo) ## [1] &quot;filename&quot; &quot;term&quot; &quot;nGenes&quot; ## [4] &quot;nQuery&quot; &quot;nOverlap&quot; &quot;querySetFraction&quot; ## [7] &quot;geneSetFraction&quot; &quot;foldEnrichment&quot; &quot;P&quot; ## [10] &quot;FDR&quot; &quot;overlapGenes&quot; &quot;maxOverlapGeneScore&quot; ## [13] &quot;cluster&quot; &quot;id&quot; &quot;size&quot; ## [16] &quot;formattedLabel&quot; # View(hresp$enrichInfo[,c(2,3,4,5,10)]) Let’s check the overlap between the enriched terms found using runGORESP and those found using fgseaSimple as they used the same GO term libraries: w = which(fposgsea$padj &lt;= 0.2) lens &lt;- length(intersect(fposgsea$pathway[w],hresp$enrichInfo$term)) length(w) ## [1] 622 dim(hresp$enrichInfo) ## [1] 238 16 percent_overlap &lt;- lens/nrow(hresp$enrichInfo)*100 percent_overlap ## [1] 83.19328 80%, that’s very good, especially because we are using two different GO enrichment methods, over-representation analysis and GSEA. The overlap between these enrichment and the ones using the other GO enrichment tools will be very small because of the differences in the GO annotation libraries. Now to set up the results for viewing in a network, we use the function visSetup, which creates a set of nodes and edges in the network, where nodes are GO terms (node size proportional to FDR score) and edges represent the overlap between GO terms (proportional to edge width). This network analysis is based on Cytoscape, an open source bioinformatics software platform for visualizing molecular interaction networks. vis = visSetup(hresp$enrichInfo,hresp$edgeMat) names(vis) ## [1] &quot;nodes&quot; &quot;edges&quot; Now we use runNetwork to view the map: runNetwork(vis$nodes,vis$edges) This is one of the best visualizations available out of all the GO packages. There are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, such as a GMT for MSigDB called c2. ** The C2 subcollection CGP: Chemical and genetic perturbations. Gene sets that represent expression signatures of genetic and chemical perturbations.** 9.8.4 Other tools and resources GeneMANIA. GeneMANIA finds other genes that are related to a set of input genes, using a very large set of functional association data curated from the literature. Association data include protein and genetic interactions, pathways, co-expression, co-localization and protein domain similarity. ReviGO. Revigo is an online GO enrichment tool that allows you to copy-paste your significant gene list and your background gene list. The output is a visualization of enriched GO terms in a hierarchical tree. AmiGO. AmiGO is the current official web-based set of tools for searching and browsing the Gene Ontology database. DAVID. The fold enrichment is defined as the ratio of the two proportions; one is the proportion of genes in your list belong to certain pathway, and the other is the proportion of genes in the background information (i.e., universe genes) that belong to that pathway. etc. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
