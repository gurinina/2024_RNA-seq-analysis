# Code book


```{r, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## Differential gene expression (DGE) analysis overview

<img src="img/rnaseq_full_workflow.png" width="400">

In the next few lessons, we will walk you through an **end-to-end gene-level RNA-seq differential expression workflow** using various R packages. We will start with the count matrix, perform exploratory data analysis for quality assessment and to explore the relationship between samples, perform differential expression analysis, and visually explore the results prior to performing downstream functional analysis.

## Review of the dataset

The RNA-Seq was performed on HEK293F cells that were either transfected with a MOV10 transgene, or siRNA to knock down Mov10 expression, or non-specific (irrelevant) siRNA. This resulted in 3 conditions **Mov10 oe** (over expression), **Mov10 kd** (knock down) and **Irrelevant kd**, respectively. The number of replicates is as shown below. 

Using these data, we will evaluate transcriptional patterns associated with perturbation of MOV10 expression. Please note that the irrelevant siRNA will be treated as our control condition.

<img src="img/dataset.png" width="400">


## Setting up

### Loading libraries
```{r, message=FALSE}
### Setup: Use BiocManager::install if you haven't already installed these libraries
### Bioconductor and CRAN libraries used
library(tidyverse)
library(RColorBrewer)
library(DESeq2)
library(pheatmap)
library(DEGreport)
library(ggplot2)
library(ggrepel)
```

### Loading data
```{r}
## Load in data
data <- read.table("data/Mov10_full_counts.txt", header=T, row.names=1) 

meta <- read.table("meta/Mov10_full_meta.txt", header=T, row.names=1)
```

```{r}
### Check classes of the data we just brought in
class(meta)
class(data)
```

### Viewing data

```{r}
View(meta)
View(data)
```
### RNA-seq count distribution

To determine the appropriate statistical model, we need information about the distribution of counts. To get an idea about how RNA-seq counts are distributed, let’s plot the counts for a single sample, ‘Mov10_oe_1’:

```{r}
ggplot(data) +
geom_histogram(aes(x = Mov10_oe_1), stat = "bin", bins = 200) +
  xlab("Raw expression counts") +
  ylab("Number of genes")
```
If we zoom in close to zero, we can see a large number of genes with counts of zero:
```{r}
ggplot(data) +
geom_histogram(aes(x = Mov10_oe_1), stat = "bin", bins = 200) + 
   xlim(-5, 500)  +
   xlab("Raw expression counts") +
   ylab("Number of genes")
```
These images illustrate some common features of RNA-seq count data, including a low number of counts associated with a large proportion of genes, and a long right tail due to the lack of any upper limit for expression. 


## Modeling count data
**How do I know if my data should be modeled using the Poisson distribution or Negative Binomial distribution?**
If it’s count data, it should fit the negative binomial, as discussed previously.

```{r}
mean_counts <- apply(data[, 3:5], 1, mean)
variance_counts <- apply(data[, 3:5], 1, var)
df <- data.frame(mean_counts, variance_counts)

ggplot(df) +
  geom_point(aes(x=mean_counts, y=variance_counts)) + 
  geom_line(aes(x=mean_counts, y=mean_counts, color="red")) +
  scale_y_log10() +
  scale_x_log10()
```

Note that in the above figure, the variance across replicates tends to be greater than the mean (red line), especially for genes with large mean expression levels. This is a good indication that our data do not fit the Poisson distribution and we need to account for this increase in variance using the Negative Binomial model (i.e. Poisson will underestimate variability leading to an increase in false positive DE genes).

We will be using DESeq2 for the DE analysis, and the analysis steps with DESeq2 are shown in the flowchart below in green. DESeq2 first normalizes the count data to account for differences in library sizes and RNA composition between samples. Then, we will use the normalized counts to make some plots for QC at the gene and sample level. The final step is to use the appropriate functions from the DESeq2 package to perform the differential expression analysis.

<img src="img/deseq_workflow_full_2018.png" width="500">

# DGE count normalization with DESeq2

## Normalization

The first step in the DE analysis workflow is count normalization, which is necessary to make accurate comparisons of gene expression between samples.

<img src="img/deseq_workflow_normalization_2018.png" width="400">

## DESeq2-normalized counts: Median of ratios method

### Step 1: creates a pseudo-reference sample (row-wise geometric mean)

For each gene, a pseudo-reference sample is created that is equal to the geometric mean across all samples.

| gene | sampleA | sampleB | pseudo-reference sample  |
| ----- |:-----:|:-----:|:-----:|
| EF2A | 1489 | 906 | sqrt(1489 * 906) = **1161.5** |
| ABCD1 | 22 | 13 | sqrt(22 * 13) = **17.7** |
| ... | ... | ... | ... |

### Step 2: calculates ratio of each sample to the reference

For every gene in a sample, the ratios (sample/ref) are calculated (as shown below). This is performed for each sample in the dataset. Since the majority of genes are not differentially expressed, the majority of genes in each sample should have similar ratios within the sample.

| gene | sampleA | sampleB | pseudo-reference sample  | ratio of sampleA/ref | ratio of sampleB/ref |
| ----- |:-----:|:-----:|:-----:| :-----: | :-----: |
| EF2A | 1489 | 906 | 1161.5 | 1489/1161.5 = **1.28** | 906/1161.5 = **0.78** |
| ABCD1 | 22 | 13 | 16.9 | 22/16.9 = **1.30** | 13/16.9 = **0.77** |
| MEFV | 793 | 410 | 570.2 | 793/570.2 = **1.39** | 410/570.2 = **0.72**
| BAG1 | 76 | 42 | 56.5 | 76/56.5 = **1.35** | 42/56.5 = **0.74**
| MOV10 | 521 | 1196 | 883.7 | 521/883.7 = **0.590** | 1196/883.7 = **1.35** |
| ... | ... | ... | ... |

### Step 3: calculate the normalization factor for each sample (size factor)

The median value (column-wise for the above table) of all ratios for a given sample is taken as the normalization factor (size factor) for that sample, as calculated below. Notice that the differentially expressed genes should not affect the median value:

`normalization_factor_sampleA <- median(c(1.28, 1.3, 1.39, 1.35, 0.59))`

`normalization_factor_sampleB <- median(c(0.78, 0.77, 0.72, 0.74, 1.35))`
 
The figure below illustrates the median value for the distribution of all gene ratios for a single sample (frequency is on the y-axis).

<img src="img/deseq_median_of_ratios.png" width="400">

The median of ratios method makes the assumption that not ALL genes are differentially expressed; therefore, the normalization factors should account for sequencing depth and RNA composition of the sample (large outlier genes will not represent the median ratio values). **This method is robust to imbalance in up-/down-regulation and large numbers of differentially expressed genes.**

**Usually these size factors are around 1, if you see large variations between samples it is important to take note since it might indicate the presence of extreme outliers.**

### Step 4: calculate the normalized count values using the normalization factor

This is performed by dividing each raw count value in a given sample by that sample's normalization factor to generate normalized count values. This is performed for all count values (every gene in every sample). For example, if the median ratio for SampleA was 1.3 and the median ratio for SampleB was 0.77, you could calculate normalized counts as follows:

SampleA median ratio = 1.3

SampleB median ratio = 0.77

**Raw Counts**

| gene | sampleA | sampleB |  
| ----- |:-----:|:-----:|
| EF2A | 1489 | 906 | 
| ABCD1 | 22 | 13 | 
| ... | ... | ... | 

**Normalized Counts**

| gene | sampleA | sampleB |
| ----- |:-----:|:-----:|
| EF2A | 1489 / 1.3 = **1145.39** | 906 / 0.77 = **1176.62** | 
| ABCD1 | 22 / 1.3 = **16.92** | 13 / 0.77 = **16.88** | 
| ... | ... | ... | 


### Exercise

Determine the normalized counts for your gene of interest, PD1, given the raw counts and size factors below.

NOTE: You will need to run the code below to generate the raw counts dataframe (PD1) and the size factor vector (size_factors), then use these objects to determine the normalized counts values:

```{r}
# Raw counts for PD1
PD1 <- c(21, 58, 17, 97, 83, 10)
names(PD1) <- paste0("Sample", 1:6)
PD1 <- data.frame(PD1)
PD1 <- t(PD1)

# Size factors for each sample
size_factors <- c(1.32, 0.70, 1.04, 1.27, 1.11, 0.85)
```

Normalized counts:
```{r}

```

## Count normalization of Mov10 dataset using DESeq2

### 1. Match the metadata and counts data
```{r}
### Check that sample names match in both files
all(colnames(data) %in% rownames(meta))
all(colnames(data) == rownames(meta))
```
#### Exercise

Suppose we had sample names matching in the counts matrix and metadata file, but they were out of order. Write the line(s) of code required to create a new matrix with columns ordered such that they were identical to the row names of the metadata.

```{r}
idx = match(rownames(meta),colnames(data))
data = data[,idx]
```

### 2. Create DESEq2 object

```{r}
## Create DESeq2Dataset object

dds <- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype)
```
You can use DESeq-specific functions to access the different slots and retrieve information, if you wish. For example, suppose we wanted the original count matrix we would use counts() (Note: we nested it within the View() function so that rather than getting printed in the console we can see it in the script editor):

```{r}
head(counts(dds))

colData(dds)
```
As we go through the workflow we will use the relevant functions to check what information gets stored inside our object.

### 3. Generate the Mov10 normalized counts

The next step is to normalize the count data in order to be able to make fair gene comparisons between samples.

<img src="img/deseq_workflow_normalization_2018.png" width="400">

To perform the **median of ratios method** of normalization, DESeq2 has a single `estimateSizeFactors()` function that will generate size factors for us. We will use the function in the example below, but **in a typical RNA-seq analysis this step is automatically performed by the `DESeq()` function**, which we will see later. 

```{r}
dds <- estimateSizeFactors(dds)
```

By assigning the results back to the dds object we are filling in the slots of the DESeqDataSet object with the appropriate information. We can take a look at the normalization factor applied to each sample using:
```{r}
sizeFactors(dds)
```

Now, to retrieve the normalized counts matrix from dds, we use the counts() function and add the argument normalized=TRUE.
```{r}
normalized_counts <- counts(dds, normalized=TRUE)
```

We can save this normalized data matrix to file for later use:
```{r}
write.table(normalized_counts, file="data/normalized_counts.txt", sep="\t", quote=F, col.names=NA)
```

**NOTE:** DESeq2 doesn’t actually use normalized counts, rather it uses the raw counts and models the normalization inside the Generalized Linear Model (GLM). These normalized counts will be useful for downstream visualization of results, but cannot be used as input to DESeq2 or any other tools that peform differential expression analysis which use the negative binomial model.

# DGE QC analysis

## Quality Control

The next step in the DESeq2 workflow is QC, which includes sample-level and gene-level steps to perform QC checks on the count data to help us ensure that the samples/replicates look good. 

<img src="img/deseq_workflow_qc_2018.png" width="400">

### Sample-level QC

When using these unsupervised clustering methods, log2-transformation of the normalized counts improves the distances/clustering for visualization. DESeq2 uses a regularized log transform (rlog) of the normalized counts for sample-level QC as it moderates the variance across the mean, improving the clustering.

### Principal Component Analysis (PCA)

Principal Component Analysis (PCA) is a technique used to emphasize variation and bring out strong patterns in a dataset (dimensionality reduction). 

**If two samples have similar levels of expression for the genes that contribute significantly to the variation represented by PC1, they will be plotted close together on the PC1 axis.** Therefore, we would expect that biological replicates to have similar scores (since the same genes are changing) and cluster together on PC1 and/or PC2, and the samples from different treatment groups to have different score. This is easiest to understand by visualizing example PCA plots.

Depending on how much variation is explained by the first few principal components, you may want to explore more (i.e consider more components and plot pairwise combinations). Even if your samples do not separate clearly by the experimental variable, you may still get biologically relevant results from the DE analysis. If you are expecting very small effect sizes, then it’s possible the signal is drowned out by extraneous sources of variation. In situations where you can identify those sources, it is important to account for these in your model, as it provides more power to the tool for detecting DE genes.

#### Exercise

The figure below was generated from a time course experiment with sample groups ‘Ctrl’ and ‘Sci’ and the following timepoints: 0h, 2h, 8h, and 16h.

- Determine the sources explaining the variation represented by PC1 and PC2.

  - Ans: 

- Do the sample groups separate well?

  - Ans: 
 
- Do the replicates cluster together for each sample group?

  - Ans: 

- Are there any outliers in the data?

  - Ans: 
 
- Should we have any other concerns regarding the samples in the dataset?

  - Ans: 

<img src="img/PCA_example3.png" width="600">

### Hierarchical Clustering Heatmap

Similar to PCA, hierarchical clustering is another, complementary method for identifying strong patterns in a dataset and potential outliers. The heatmap displays the correlation of gene expression for all pairwise combinations of samples in the dataset. Since the majority of genes are not differentially expressed, samples generally have high correlations with each other (values higher than 0.80). Samples below 0.80 may indicate an outlier in your data and/or sample contamination.

The hierarchical tree can indicate which samples are more similar to each other based on the normalized gene expression values. The color blocks indicate substructure in the data, and you would expect to see your replicates cluster together as a block for each sample group. Additionally, we expect to see samples clustered similar to the groupings observed in a PCA plot.


**In the plot below, we would be quite concerned about 'Wt_3' and 'KO_3' samples not clustering with the other replicates. We would want to explore the PCA to see if we see the same clustering of samples.**

<img src="img/heatmap_example.png" width="500">

### Gene-level QC

In addition to examining how well the samples/replicates cluster together, there are a few more QC steps. Prior to differential expression analysis it is beneficial to omit genes that have little or no chance of being detected as differentially expressed. This will increase the power to detect differentially expressed genes. The genes omitted fall into three categories:

 - Genes with zero counts in all samples
 - Genes with an extreme count outlier
 - Genes with a low mean normalized counts

<img src="img/gene_filtering.png" width="600">

**DESeq2 will perform this filtering by default; however other DE tools, such as EdgeR will not.**  

### Mov10 quality assessment and exploratory analysis using DESeq2

**Transform normalized counts using the rlog transformation**

To improve the distances/clustering for the PCA and heirarchical clustering visualization methods, we need to moderate the variance across the mean by applying the rlog transformation to the normalized counts.

The rlog transformation of the normalized counts is only necessary for these visualization methods during this quality assessment. We will not be using these tranformed counts downstream.

```{r}
### Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)
```
We use this object to plot the PCA and heirarchical clustering figures for quality assessment.

#### Principal components analysis (PCA)

```{r}
### Plot PCA 
plotPCA(rld, intgroup="sampletype")
```
**What does this plot tell you about the similarity of samples? Does it fit the expectation from the experimental design?** By default the function uses the top 500 most variable genes. You can change this by adding the ntop argument and specifying how many genes you want to use to draw the plot.

**NOTE:** The plotPCA() function will only return the values for PC1 and PC2. If you would like to explore the additional PCs in your data or if you would like to identify genes that contribute most to the PCs, you can use the prcomp() function. For example, to plot any of the PCs we could run the following code:

```{r}
# Input is a matrix of log transformed values
rld <- rlog(dds, blind=T)
rld_mat <- assay(rld)
pca <- prcomp(t(rld_mat))

# Create data frame with metadata and PC3 and PC4 values for input to ggplot
df <- cbind(meta, pca$x)
ggplot(df) + geom_point(aes(x=PC3, y=PC4, color = sampletype))
```

#### Hierarchical Clustering

Since there is no built-in function for heatmaps in DESeq2 we will be using the pheatmap() function from the pheatmap package. This function requires a matrix/dataframe of numeric values as input, and so the first thing we need to is retrieve that information from the rld object:

```{r}
### Extract the rlog matrix from the object
rld_mat <- assay(rld)    ## assay() is function from the "SummarizedExperiment" package that was loaded when you loaded DESeq2
```
Then we need to compute the pairwise correlation values for samples. We can do this using the cor() function:

```{r}
### Compute pairwise correlation values
rld_cor <- cor(rld_mat)    ## cor() is a base R function

head(rld_cor)   ## check the output of cor(), make note of the rownames and colnames
```

And now to plot the correlation values as a heatmap:

```{r}
### Plot heatmap
pheatmap(rld_cor)
```

**NOTE:** The pheatmap function has a number of different arguments that we can alter from default values to enhance the aesthetics of the plot. If you are curious and want to explore more, try running the code below. How does your plot change? Take a look through the help pages (?pheatmap) and identify what each of the added arguments is contributing to the plot.

```{r}
heat.colors <- brewer.pal(6, "Blues")
pheatmap(rld_cor, color = heat.colors, border_color=NA, fontsize = 10, fontsize_row = 10, height=20)
```

```{r}
display.brewer.all()
```

# DGE DESeq2 analysis partI

## Gene-level differential expression analysis with DESeq2

Differential expression analysis with DESeq2 involves multiple steps as displayed in the flowchart below in blue. Briefly, DESeq2 will model the raw counts, using normalization factors (size factors) to account for differences in library depth. Then, it will estimate the gene-wise dispersions and shrink these estimates to generate more accurate estimates of dispersion to model the counts. Finally, DESeq2 will fit the negative binomial model and perform hypothesis testing using the Wald test or Likelihood Ratio Test.

<img src="img/DESeq2_workflow_2018.png" width="500">

### Running DESeq2

#### Design formula

A design formula tells the statistical software the known sources of variation to control for, as well as, the factor of interest to test for during differential expression testing. After performing the QC analysis (or based on your experimental design) you should have a good idea of the sources of variation.

For example, suppose you have the following metadata:

<img src="img/meta_example.png" width="300">

If you want to examine the expression differences between treatments, and you know that major sources of variation include `sex` and `age`, then your design formula would be:

```{r, eval=FALSE}
design <- ~ sex + age + treatment

```
The tilde (`~`) should always proceed your factors and tells DESeq2 to model the counts using the following formula. Note the **factors included in the design formula need to match the column names in the metadata**. 


#### Exercise

Suppose you wanted to study the expression differences between the two age groups in the metadata shown above, and major sources of variation were `sex` and `treatment`, how would the design formula be written?

```{r, eval=FALSE}

```
Based on our Mov10 metadata dataframe, which factors could we include in our design formula?

 - Ans:

What would you do if you wanted to include a factor in your design formula that is not in your metadata?

 - Ans: 
 
 

### MOV10 DE analysis

To get our differential expression results from our raw count data, we only need to run 2 lines of code!

```{r}
## Create DESeq object
dds <- DESeqDataSetFromMatrix(countData = data, colData = meta, design = ~ sampletype)
```
Then, to run the actual differential expression analysis, we use a single call to the function DESeq().

```{r}
## Run analysis
dds <- DESeq(dds)
```

Everything from normalization to linear modeling was carried out by the use of a single function! 

With the 2 lines of code above, we just completed the workflow for the differential gene expression analysis with DESeq2. The steps in the analysis are output below:

<img src="img/deseq2_workflow_separate.png" width="200">

We will be taking a detailed look at each of these steps to better understand how DESeq2 is performing the statistical analysis and what metrics we should examine to explore the quality of our analysis.

#### Step 1: Estimate size factors

MOV10 DE analysis: examining the size factors

```{r}
## Check the size factors
sizeFactors(dds)
```
These numbers should be identical to those we generated initially when we had run the function estimateSizeFactors(dds). Take a look at the total number of reads for each sample:

```{r}
## Total number of raw counts per sample
colSums(counts(dds))
```

**How do the numbers correlate with the size factor?**

Now take a look at the total depth after normalization using:
```{r}
## Total number of normalized counts per sample
colSums(counts(dds, normalized=T))
```
How do the values across samples compare with the total counts taken for each sample?

```{r}
plot(colSums(counts(dds, normalized = F)),pch=19)
points(colSums(counts(dds, normalized = T)),pch=19, col = "blue")
```
#### Step 2: Estimate gene-wise dispersion**

Dispersion is a measure of spread or variability in the data. DESeq2 uses a specific measure of dispersion (α) related to the mean (μ) and variance of the data: Var = μ + α*μ^2. For genes with moderate to high count values, the square root of dispersion will be equal to the coefficient of variation (Var / μ). So 0.01 dispersion means 10% variation around the mean expected across biological replicates.

What does the DESeq2 dispersion represent?

The DESeq2 dispersion estimates are inversely related to the mean and directly related to variance. Based on this relationship, the dispersion is higher for small mean counts and lower for large mean counts. 

How does the dispersion relate to our model?

To accurately model sequencing counts, we need to generate accurate estimates of within-group variation (variation between replicates of the same sample group) for each gene. With only a few (3-6) replicates per group, the estimates of variation for each gene are often unreliable (due to the large differences in dispersion for genes with similar means).

To address this problem, DESeq2 shares information across genes to generate more accurate estimates of variation based on the mean expression level of the gene using a method called ‘shrinkage’. DESeq2 assumes that genes with similar expression levels have similar dispersion.

Estimating the dispersion for each gene separately:

To model the dispersion based on expression level (mean counts of replicates), the dispersion for each gene is estimated using maximum likelihood estimation. In other words, given the count values of the replicates, the most likely estimate of dispersion is calculated.

#### Step 3: Fit curve to gene-wise dispersion estimates

The next step in the workflow is to fit a curve to the dispersion estimates for each gene. The idea behind fitting a curve to the data is that different genes will have different scales of biological variability, but, over all genes, there will be a distribution of reasonable estimates of dispersion.

#### Step 4: Shrink gene-wise dispersion estimates toward the values predicted by the curve

Dispersion plots are a good way to examine your data to ensure it is a good fit for the DESeq2 model.

Let’s take a look at the dispersion estimates for our MOV10 data:

```{r}
## Plot dispersion estimates
plotDispEsts(dds)
```
Since we have a small sample size, for many genes we see quite a bit of shrinkage. Do you think our data are a good fit for the model?

# DGE DESeq2 analysis partII

## Differential expression analysis with DESeq2: model fitting and hypothesis testing

## Generalized Linear Model fit for each gene

The final step in the DESeq2 workflow is fitting the Negative Binomial model for each gene and performing differential expression testing.

<img src="img/deseq2_workflow_separate_2018.png" width="400">

## Shrunken log2 foldchanges (LFC)


To generate more accurate log2 foldchange estimates, DESeq2 allows for the **shrinkage of the LFC estimates toward zero** when the information for a gene is low, which could include:

- Low counts
- High dispersion values

As with the shrinkage of dispersion estimates, LFC shrinkage uses **information from all genes** to generate more accurate estimates. Specifically, the distribution of LFC estimates for all genes is used (as a prior) to shrink the LFC estimates of genes with little information or high dispersion toward more likely (lower) LFC estimates. 

<img src="img/deseq2_shrunken_lfc.png" width="500">

## Hypothesis testing using the Wald test

With DESeq2, the Wald test is commonly used for hypothesis testing when comparing two groups. A Wald test statistic is computed along with a probability that a test statistic at least as extreme as the observed value were selected at random. This probability is called the p-value of the test. If the p-value is small we reject the null hypothesis and state that there is evidence against the null (i.e. the gene is differentially expressed).

### Creating contrasts

To indicate to DESeq2 the two groups we want to compare, we can use contrasts. Contrasts are then provided to DESeq2 to perform differential expression testing using the Wald test. Contrasts can be provided to DESeq2 a couple of different ways:

Do nothing. Automatically DESeq2 will use the base factor level of the condition of interest as the base for statistical testing. The base level is chosen based on alphabetical order of the levels.

In the results() function you can specify the comparison of interest, and the levels to compare. The level given last is the base level for the comparison. The syntax is given below:

```{r, eval=FALSE}
# DO NOT RUN!
contrast <- c("condition", "level_to_compare", "base_level")
results(dds, contrast = contrast, alpha = alpha_threshold)
```

#### MOV10 DE analysis: contrasts and Wald tests

We have three sample classes so we can make three possible pairwise comparisons:

1. Control vs. Mov10 overexpression
2. Control vs. Mov10 knockdown
3. Mov10 knockdown vs. Mov10 overexpression

**We are really only interested in #1 and #2 from above**. Using the design formula we provided `~ sampletype`, indicating that this is our main factor of interest.

### Building the results table

```{r}
## Define contrasts, extract results table, and shrink the log2 fold changes

contrast_oe <- c("sampletype", "MOV10_overexpression", "control")

res_tableOE_unshrunken <- results(dds, contrast=contrast_oe, alpha = 0.05)

# the other way of getting the results is to use the coefficients instead of contrast.
resultsNames(dds)

res_tableOE_unshrunken <- results(dds, name = "sampletype_MOV10_overexpression_vs_control", alpha = 0.05)

res_tableOE <- lfcShrink(dds, contrast = contrast_oe, res=res_tableOE_unshrunken, type = "ashr")

#OR

res_tableOE <- lfcShrink(dds, coef = "sampletype_MOV10_overexpression_vs_control", res=res_tableOE_unshrunken, type = "apeglm")

# Let's use the 2nd approach as apeglm is thought to be the superior method of lfcShrink.
# 
# We will save these results for later use in the data directory using the following command:
# 
saveRDS(res_tableOE, file = "data/res_tableOE.rds")
```
**The order of the names determines the direction of fold change that is reported.** The name provided in the second element is the level that is used as baseline. So for example, if we observe a log2 fold change of -2 this would mean the gene expression is lower in Mov10_oe relative to the control. 

### MA Plot

A plot that can be useful to exploring our results is the MA plot. The MA plot shows the mean of the normalized counts versus the log2 foldchanges for all genes tested. The genes that are significantly DE are colored to be easily identified. This is also a great way to illustrate the effect of LFC shrinkage. The DESeq2 package offers a simple function to generate an MA plot. 

**Let's start with the unshrunken results:**

Viewing the results:

```{r}
plotMA(res_tableOE_unshrunken, ylim=c(-2,2))
```
**And now the shrunken results:**
```{r}
plotMA(res_tableOE, ylim=c(-2,2))
```
This plot allows us to evaluate the magnitude of fold changes and how they are distributed relative to mean expression.

### MOV10 DE analysis: results exploration

The results table looks very much like a dataframe and in many ways it can be treated like one (i.e when accessing/subsetting data). However, it is important to recognize that it is actually stored in a `DESeqResults` object. When we start visualizing our data, this information will be helpful. 


```{r}
class(res_tableOE)
```

```{r}
mcols(res_tableOE, use.names=T)
```

```{r}
res_tableOE %>% data.frame() %>% head()
```
If we used the `p-value` directly from the Wald test with a significance cut-off of p < 0.05, that means there is a 5% chance it is a false positives. Each p-value is the result of a single test (single gene). The more genes we test, the more we inflate the false positive rate. **This is the multiple testing problem.** 

In DESeq2, the p-values attained by the Wald test are corrected for multiple testing using the Benjamini and Hochberg method by default. There are options to use other methods in the `results()` function. The p-adjusted values should be used to determine significant genes. 

### MOV10 DE analysis: Control versus Knockdown

Now that we have results for the overexpression results, let's do the same for the **Control vs. Knockdown samples**. Use contrasts in the `results()` to extract a results table and store that to a variable called `res_tableKD`.  
```{r}
res_tableKD_unshrunken <- results(dds, name =  "sampletype_MOV10_knockdown_vs_control", alpha = 0.05)

res_tableKD <- lfcShrink(dds, coef =  "sampletype_MOV10_knockdown_vs_control", res=res_tableKD_unshrunken)

# We will save these results for later use in the data directory using the following command:
# 
saveRDS(res_tableKD, file = "data/res_tableKD.rds")
```

```{r}
table(res_tableKD$padj < 0.05)

table(res_tableOE$padj < 0.05)

table(res_tableKD$padj < 0.05 & abs(res_tableKD$log2FoldChange) >=1)

table(res_tableOE$padj < 0.05 & abs(res_tableOE$log2FoldChange) >=1)
```
## Summarizing results

To summarize the results table, a handy function in DESeq2 is `summary()`. Confusingly it has the same name as the function used to inspect data frames. This function when called with a DESeq results table as input, will summarize the results using the alpha threshold: FDR < 0.05 (padj/FDR is used even though the output says `p-value < 0.05`). 

```{r}
summary(res_tableKD)
summary(res_tableOE)
```
### Extracting significant differentially expressed genes

What we noticed is that the FDR threshold on it's own doesn't appear to be reducing the number of significant genes. With large significant gene lists it can be hard to extract meaningful biological relevance. To help increase stringency, one can also **add a fold change threshold**.

```{r}
### Set thresholds
padj.cutoff <- 0.05
lfc.cutoff <- 0.58 ## change in expression of 1.5
```
The lfc.cutoff is set to 0.58; remember that we are working with log2 fold changes so this translates to an actual fold change of 1.5 which is pretty reasonable.

We can easily subset the results table to only include those that are significant using the filter() function, but first we will convert the results table into a tibble:

```{r}
res_tableOE_tb <- res_tableOE %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()

sigOE <- res_tableOE_tb %>%
        filter(padj < padj.cutoff & abs(log2FoldChange) > lfc.cutoff)
```
**How many genes are differentially expressed in the Overexpression compared to Control, given our criteria specified above? Does this reduce our results?**

```{r}
nrow(sigOE)
```

  - Ans: 
  
Does this reduce our results?

  -Ans: 

```{r}
res_tableKD_tb <- res_tableKD %>%
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()
  
sigKD <- res_tableKD_tb %>%
        filter(padj < padj.cutoff & abs(log2FoldChange) > lfc.cutoff)

# We'll save this object for use in the homework
# 
saveRDS(sigKD,"data/sigKD.rds")
```
### Exercise

**How many genes are differentially expressed in the Knockdown compared to Control?** 

```{r}

```
  - Ans: 

### An alternative approach

The `results()` function has an option to add a fold change threshold using the `lfcThrehsold` argument. This method is more statistically motivated, and is recommended when you want a more confident set of genes based on a certain fold-change. It actually performs a statistical test against the desired threshold, by performing a two-tailed test for log2 fold changes greater than the absolute value specified.

Test this out using our data:
```{r}
res_OE_lfc <- results(dds, contrast = contrast_oe, alpha = 0.05, lfcThreshold = 0.58)

w=which(res_OE_lfc$padj < 0.05 & abs(res_OE_lfc$log2FoldChange)> 0.58)

length(w)
```

**How do the results differ? How many significant genes do we get using this approach?**

  - Ans: 

# DGE visualizing results

## Advanced visualizations

When we are working with large amounts of data it can be useful to display that information graphically to gain more insight.

Let’s create tibble objects from the meta and normalized_counts data frames before we start plotting. This will enable us to use the tidyverse functionality more easily.

Basically, we are taking the rownames and adding them as a field in the tibble/data.frame.

```{r}
# Create tibbles including row names
mov10_meta <- meta %>% 
  rownames_to_column(var="samplename") %>% 
  as_tibble()
        
normalized_counts <- normalized_counts %>% 
  data.frame() %>%
  rownames_to_column(var="gene") %>% 
  as_tibble()
```

### Plotting signicant DE genes

One way to visualize results would be to simply plot the expression data for a handful of genes. We could do that by picking out specific genes of interest or selecting a range of genes.

#### **Using DESeq2 `plotCounts()` to plot expression of a single gene**

To pick out a specific gene of interest to plot, for example Mov10, we can use the `plotCounts()` from DESeq2:

```{r}
# Plot expression for single gene
plotCounts(dds, gene="MOV10", intgroup="sampletype",pch=19,col=as.numeric(as.factor(meta$sampletype))) 
```
#### **Using ggplot2 to plot expression of a single gene**

If you wish to change the appearance of this plot, we can save the output of `plotCounts()` to a variable specifying the `returnData=TRUE` argument, then use `ggplot()`:

```{r}
# Save plotcounts to a data frame object
d <- plotCounts(dds, gene="MOV10", intgroup="sampletype", returnData=TRUE)

# Plotting the MOV10 normalized counts, using the samplenames (rownames of d as labels)
ggplot(d, aes(x = sampletype, y = count, color = sampletype)) +   geom_point(position=position_jitter(w = 0.1,h = 0)) +
  geom_text_repel(aes(label = rownames(d))) + 
  theme_bw() +
  ggtitle("MOV10") +
  theme(plot.title = element_text(hjust = 0.5))
```
#### Using `ggplot2` to plot multiple genes (e.g. top 20)

Often it is helpful to check the expression of multiple genes of interest at the same time. This often first requires some data wrangling.

We are going to plot the normalized count values for the **top 20 differentially expressed genes (by padj values)**. 

```{r}
## Order results by padj values
top20_sigOE_genes <- res_tableOE_tb %>% 
  arrange(padj) %>%   #Arrange rows by padj values
  pull(gene) %>% #Extract character vector of ordered genes
  head(n=20)      #Extract the first 20 genes
```
Then, we can extract the normalized count values for these top 20 genes:

```{r}
## normalized counts for top 20 significant genes
top20_sigOE_norm <- normalized_counts %>%
        filter(gene %in% top20_sigOE_genes)
```

Now that we have the normalized counts for each of the top 20 genes for all 8 samples, to plot using ggplot(), we need to gather the counts for all samples into a single column to allow us to give ggplot the one column with the values we want it to plot.

The gather() function in the tidyr package will perform this operation and will output the normalized counts for all genes for Mov10_oe_1 listed in the first 20 rows, followed by the normalized counts for Mov10_oe_2 in the next 20 rows, so on and so forth.

<img src="img/melt_wide_to_long_format.png" width="800">

```{r}
# Gathering the columns to have normalized counts to a single column
gathered_top20_sigOE <- top20_sigOE_norm %>%
  gather(colnames(top20_sigOE_norm)[2:9], key = "samplename", value = "normalized_counts")

## check the column header in the "gathered" data frame
head(gathered_top20_sigOE)
```

Now, if we want our counts colored by sample group, then we need to combine the metadata information with the melted normalized counts data into the same data frame for input to `ggplot()`:

```{r}
gathered_top20_sigOE <- inner_join(mov10_meta, gathered_top20_sigOE)
```
The inner_join() will merge 2 data frames with respect to the “samplename” column, i.e. a column with the same column name in both data frames.

Now that we have a data frame in a format that can be utilised by ggplot easily, let’s plot!

```{r}
## plot using ggplot2
ggplot(gathered_top20_sigOE) +
geom_point(aes(x = gene, y = normalized_counts, color = sampletype)) +
scale_y_log10() +
xlab("Genes") +
ylab("log10 Normalized Counts") +
ggtitle("Top 20 Significant DE Genes") +
theme_bw() +
theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
theme(plot.title = element_text(hjust = 0.5))
```

### Heatmap

In addition to plotting subsets, we could also extract the normalized values of *all* the significant genes and plot a heatmap of their expression using `pheatmap()`.
```{r}
### Extract normalized expression for significant genes from the OE and control samples (4:9), and set the gene column (1) to row names
norm_OEsig <- normalized_counts[,c(1,4:9)] %>% 
              filter(gene %in% sigOE$gene) %>% 
          data.frame() %>%
          column_to_rownames(var = "gene") 
```

Now let’s draw the heatmap using pheatmap:
```{r}
### Annotate our heatmap (optional)
annotation <- mov10_meta %>% 
    select(samplename, sampletype) %>% 
    data.frame(row.names = "samplename")

### Set a color palette
heat_colors <- brewer.pal(6, "YlOrRd")

### Run pheatmap
pheatmap(norm_OEsig, 
         color = heat_colors, 
         cluster_rows = T, 
         show_rownames = F,
         annotation = annotation, 
         border_color = NA, 
         fontsize = 10, 
         scale = "row", 
         fontsize_row = 10, 
         height = 20)
```

### Volcano plot

The above plot would be great to look at the expression levels of a good number of genes, but for more of a global view there are other plots we can draw. A commonly used one is a volcano plot; in which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis.

To generate a volcano plot (which you have the log transformed adjusted p-values plotted on the y-axis and log2 fold change values on the x-axis), we first need to have a column in our results data indicating whether or not the gene is considered differentially expressed based on p-adjusted values.
```{r}
## Obtain logical vector where TRUE values denote padj values < 0.05 and fold change > 1.5 in either direction

res_tableOE_tb <- res_tableOE_tb %>% 
                  mutate(threshold_OE = padj < 0.05 & abs(log2FoldChange) >= 0.58)
```

Now we can start plotting. 
```{r}
## Volcano plot
ggplot(res_tableOE_tb) +
      geom_point(aes(x = log2FoldChange, y = -log10(padj), colour = threshold_OE)) +
      ggtitle("Mov10 overexpression") +
      xlab("log2 fold change") + 
      ylab("-log10 adjusted p-value") +
      #scale_y_continuous(limits = c(0,50)) +
      theme(legend.position = "none",
      plot.title = element_text(size = rel(1.5), hjust = 0.5),
      axis.title = element_text(size = rel(1.25)))
```

What if we also wanted to know where the top 10 genes (lowest padj) in our DE list are located on this plot? We could label those dots with the gene name on the Volcano plot using `geom_text_repel()`.

First, we need to order the res_tableOE tibble by padj, and add an additional column to it, to include on those gene names we want to use to label the plot.
```{r}
## Create a column to indicate which genes to label
res_tableOE_tb <- res_tableOE_tb %>% arrange(padj) %>% mutate(genelabels = "")

res_tableOE_tb$genelabels[1:10] <- res_tableOE_tb$gene[1:10]

head(res_tableOE_tb)
```

Next, we plot it as before with an additional layer for `geom_text_repel()` wherein we can specify the column of gene labels we just created.
```{r}
ggplot(res_tableOE_tb, aes(x = log2FoldChange, y = -log10(padj))) +
      geom_point(aes(colour = threshold_OE)) +
      geom_text_repel(aes(label = genelabels)) +
      ggtitle("Mov10 overexpression") +
      xlab("log2 fold change") + 
      ylab("-log10 adjusted p-value") +
      theme(legend.position = "none",
      plot.title = element_text(size = rel(1.5), hjust = 0.5),
      axis.title = element_text(size = rel(1.25))) 
```

**NOTE:** The package 'DEGreport' can use the DESeq2 results output to make the top20 genes and the volcano plots generated above by writing a few lines of simple code. While you can customize the plots above, you may be interested in using this code although it is not very straightforward. Below are examples of the code to create these plots:
```{r}

res_tableOE_tb <- res_tableOE_tb %>% arrange(padj)
res_tableOE <- res_tableOE[res_tableOE_tb$gene,]

anno <- as.data.frame(rowData(dds)) # rowData returns all of the metadata columns that are generated during the analysis: e.g. dispersion, baseMean, baseVar

anno$gene <- rownames(dds) # add gene to rowData

anno$symbol <- anno$gene # add symbol because degPlot asks for two colnames for the ann var

rowData(dds) <- anno

idx <- match(res_tableOE_tb$gene,rownames(dds)) # sort the rows of dds by padj
dse <- dds[idx,]

palette = "Set1" # palette from RColorBrewer, color argument  palette compatible with ggplot2::scale_color_brewer().

d <- degPlot(dds = dse,xs = "sampletype",res = res_tableOE,n = 9, genes=rownames(dse)[1:9],group = "sampletype",ann = c("gene","symbol"),color=palette)

d + theme(axis.text.x=element_text(angle=45, hjust=1)) + ggtitle("Top 9 genes: log2 counts vs sampletype")
```

```{r}
library(rafalib)
mypar(1,1)
stats <- res_tableOE[,c("log2FoldChange", "padj")]
stats[["name"]] <- row.names(stats)


degVolcano(stats, plot_text = stats[1:10,]) # this is not very helpful because we get the error ggrepel: 9 unlabeled data points (too many overlaps). Consider increasing max.overlaps -- which we can't change unless we modify the function
```

```{r}
# modifying the function
stats <- as.data.frame(stats)
names(stats) = c("logFC", "adj.P.Val","name")
stats[, 2] = -log10(stats[, 2] + 1e-10)

if (sum(rowSums(is.na(stats))) > 0)
stats = stats[rowSums(is.na(stats)) == 0, ]

range.lfc <- c(floor(min(stats$logFC)), ceiling(max(stats$logFC)))
range.pval <- c(floor(min(stats$adj.P.Val)), ceiling(max(stats$adj.P.Val)))
fmt <- DEGreport:::fmt # hidden function in DEGreport for formatting numbers

fmt

plot_text <- as.data.frame(stats[1:9,])
point.outline.colour="black"
point.colour="navy"


scatter <- ggplot(stats, aes_string(x = "logFC", y = "adj.P.Val")) + 
    geom_point(alpha = 0.25, pch = 19, fill = point.colour, 
               color = point.outline.colour) + xlab("log2 fold change") + 
    ylab("-log10(adjusted p-value)") + theme_bw() + theme(legend.position = "none") + 
    theme(plot.margin = unit(c(3, -5.5, 4, 3), "mm")) + scale_y_continuous(labels = fmt(), 
    limits = range.pval) + ggtitle("Volcano plot")

scatter+ geom_text_repel(data = plot_text, aes_string(x = "logFC", y = "adj.P.Val", label = "name"),
    size = 3,max.overlaps = 20)

```

```{r, fig.width=10.5,fig.height=5.25}

d <- degPlotWide(dds, genes=res_tableOE_tb$gene[1:9], group = "sampletype")
sq = seq(from=0.5,to=10,1)
d +  geom_vline(xintercept=sq,color="gray") # makes it easier to see individual genes
```


# DGE summarizing workflow

## Summary of differential expression analysis workflow

```{r, message=FALSE}
## Setup
### Bioconductor and CRAN libraries used
library(DESeq2)
```

We have detailed the various steps in a differential expression analysis workflow, providing theory with example code. To provide a more succinct reference for the code needed to run a DGE analysis, we have summarized the steps in an analysis below:

### 1. Import data into dds object:
```{r, eval=FALSE}

# Check that the row names of the metadata equal the column names of the **raw counts** data
all(colnames(raw_counts) == rownames(metadata))

# Create DESeq2Dataset object
dds <- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition)

```

### 2. Exploratory data analysis (PCA & heirarchical clustering) - identifying outliers and sources of variation in the data:
```{r, eval=FALSE}
# Transform counts for data visualization
rld <- rlog(dds, blind=TRUE)

# Plot PCA 
plotPCA(rld, intgroup="condition")

# Extract the rlog matrix from the object
rld_mat <- assay(rld)

# Compute pairwise correlation values
rld_cor <- cor(rld_mat)

# Plot heatmap
pheatmap(rld_cor)
```

### 3. Run DESeq2:
```{r, eval=FALSE}
    # **Optional step** - Re-create DESeq2 dataset if the design formula has changed after QC analysis in include other sources of variation
    dds <- DESeqDataSetFromMatrix(countData = raw_counts, colData = metadata, design = ~ condition)

# Run DESeq2 differential expression analysis
dds <- DESeq(dds)

    #  **Optional step** - Output normalized counts to save as a file to access outside RStudio
    normalized_counts <- counts(dds, normalized=TRUE)
```

### 4. Check the fit of the dispersion estimates:
```{r, eval=FALSE}
# Plot dispersion estimates
plotDispEsts(dds)
```

### 5. Create contrasts to perform Wald testing on the shrunken log2 foldchanges between specific conditions:
```{r, eval=FALSE}
# Output results of Wald test for contrast
contrast <- c("condition", "level_to_compare", "base_level")
coef = resultsNames(dds)
res <- results(dds, contrast = contrast)
res_tableOE <- lfcShrink(dds, contrast=contrast, res=res_tableOE_unshrunken, type = "normal")

res <- lfcShrink(dds, coef = coef[?], res=res, type = "apeglm")
```

### 6. Output significant results:
```{r, eval=FALSE}
# Turn the results object into a data frame
res_df <- data.frame(res)

# Subset the significant results
sig_res <- filter(res_df, padj < padj.cutoff & abs(log2FoldChange) > lfc.cutoff)
```

### 7. Visualize results: volcano plots, heatmaps, normalized counts plots of top genes, etc.

### 8. Make sure to output the versions of all tools used in the DE analysis:
```{r}
sessionInfo()
```
Homework: modify this file to analyze the MOV dataset.

# Functional analysis of RNAseq


```{r, message=FALSE}
# you may have to install some of these libraries; use `BiocManager::install()`
library(org.Hs.eg.db)
library(DOSE)
library(pathview)
library(clusterProfiler)
library(AnnotationHub)
library(ensembldb)
library(tidyverse)
library(enrichplot)

# if you haven't installed annotables yet, uncomment this line and install from github: devtools::install_github("stephenturner/annotables")
library(annotables)

```

Functional analysis tools are useful in interpreting resulting DGE gene lists from RNAseq, and fall into three main types:

1. Over-representation analysis
2. Functional class scoring
3. Pathway topology

## Over-representation analysis

Functional analysis tools rely on databases that typically categorize genes into groups based on shared function. The GO ontology consortium is a mission to develop an up-to-date, comprehensive, computational model of biological systems, from the molecular level to larger pathways, cellular and organism-level systems. The Gene Ontology (GO), began in 1998 when researchers studying the genome of three model organisms — Drosophila melanogaster (fruit fly), Mus musculus (mouse), and Saccharomyces cerevisiae (brewer’s or baker’s yeast) — agreed to work collaboratively on a common classification scheme for gene function, and today the number of different organisms represented in GO is in the thousands. GO makes it possible, in a flexible and dynamic way, to provide comparable descriptions of homologous gene and protein sequences across the phylogenetic spectrum. GO ontology is classified into three independent controlled vocabularies: biological process, molecular function and cellular component that are organized in a hierarchical fashion. Each GO term has a term name and a unique term association. For example, the GO term DNA repair is associated with the term accession number GO:0005125. Of the three controlled vocabularies, biological processes is the most well-characterized, and most often used in over-representation studies. The GO knowledgebase plays an essential role in supporting biomedical research and has been used in tens of thousands of scientific studies. The most common use of GO annotations is for interpretation of large-scale molecular biology experiments or “omics” experiments. Whether, genomics, transcriptomics, proteomics, or metabolomics, these experiments pool biological molecules to gain insight into the structure, function, and dynamics of an organism. “Gene Ontology enrichment analysis” is used to discover statistically significant similarities or differences under alternate controlled experimental conditions.

To determine whether any categories are over-represented in a significant gene list, the probability of the observed proportion of genes associated with a specific category is compared to the background set of genes. This statistical test is known as the "hypergeometric test".

### Analyzing GO over-representation using clusterProfiler

For the different steps in the functional analysis, we require Ensembl and Entrez IDs. To convert the gene symbols to these IDs, we will use the annotables package and merge the IDs with the DE results.

```{r}
# Explore the grch38 table loaded by the annotables library
names(grch38)
class(grch38)

res_tableOE = readRDS("data/res_tableOE.rds")

## Return the IDs for the gene symbols in the DE results
idx <- grch38$symbol %in% rownames(res_tableOE)

ids <- grch38[idx, ]

## The gene names can map to more than one Ensembl ID (some genes change ID over time), 
## so we need to remove duplicate IDs prior to assessing enriched GO terms
non_duplicates <- which(!duplicated(ids$symbol))
ids <- ids[non_duplicates, ] 

res_tableOE_tb <- res_tableOE %>%
data.frame() %>%
rownames_to_column(var="gene") %>%
as_tibble()

w = which(res_tableOE_tb$gene%in% ids$symbol)

res_ids = res_tableOE_tb[w,]
m = match(res_ids$gene,ids$symbol)

res_ids$ensgene = ids$ensgene[m]
#background set of ensgenes
allOE_genes <- res_ids$ensgene

sigOE = dplyr::filter(res_ids, padj < 0.05)
sigOE_genes = sigOE$ensgene

```

Now we can perform the GO enrichment analysis and save the results:
```{r}
## Run GO enrichment analysis 
ego <- enrichGO(gene = sigOE_genes, 
                universe = allOE_genes,
                keyType = "ENSEMBL",
                OrgDb = org.Hs.eg.db, 
                ont = "BP", 
                pAdjustMethod = "BH", 
                qvalueCutoff = 0.05, 
                readable = TRUE)
                
## Output results from GO analysis to a table
cluster_summary <- data.frame(ego)

## make sure you have a results directory
write.csv(cluster_summary, "results/clusterProfiler_Mov10oe.csv")

```

### Visualizing clusterProfiler results

#### dotplot

The dotplot shows the number of genes associated with the first 50 terms (size) and the p-adjusted values for these terms (color). This plot displays the top 50 genes by gene ratio (# genes related to GO term / total number of sig genes), not p-adjusted value.
```{r}
## Dotplot 
dotplot(ego, showCategory=50)
dotplot(ego, showCategory=15)
```
To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF.... In the pop-up window, change PDF size to 8 x 16 to give a figure of appropriate size for the text labels

#### enrichment GO plot
The next plot is the enrichment GO plot, which shows the relationship between the top 50 most significantly enriched GO terms (padj.), by grouping similar terms together. The color represents the p-values relative to the other displayed terms (brighter red is more significant) and the size of the terms represents the number of genes that are significant from our list.

This plot is useful because it serves to collapse the GO terms into functional categories by showing the overlap between GO terms.

```{r}
## Enrichmap clusters the 50 most significant (by padj) GO terms to visualize relationships between terms

pwt <- pairwise_termsim(
ego,
method = "JC",
semData = NULL,
showCategory = 50
)

emapplot(pwt, showCategory = 50)
```
To save the figure, click on the Export button in the RStudio Plots tab and Save as PDF.... In the pop-up window, change the PDF size to 24 x 32 to give a figure of appropriate size for the text labels.

Finally, the category netplot shows the relationships between the genes associated with the top five most significant GO terms and the fold changes of the significant genes associated with these terms (color). The size of the GO terms reflects the pvalues of the terms, with the more significant terms being larger. This plot is particularly useful for hypothesis generation in identifying genes that may be important to several of the most affected processes.

#### netplot
```{r}
## To color genes by log2 fold changes, we need to extract the log2 fold changes from our results table creating a named vector
OE_foldchanges <- sigOE$log2FoldChange

names(OE_foldchanges) <- sigOE$gene

## Cnetplot details the genes associated with one or more terms - by default gives the top 5 significant terms (by padj)
cnetplot(ego, 
         categorySize="pvalue", 
         showCategory = 5, 
         foldChange=OE_foldchanges, 
         vertex.label.font=6)
         
## If some of the high fold changes are getting drowned out due to a large range, you could set a maximum fold change value
OE_foldchanges <- ifelse(OE_foldchanges > 2, 2, OE_foldchanges)
OE_foldchanges <- ifelse(OE_foldchanges < -2, -2, OE_foldchanges)

cnetplot(ego, 
         categorySize="pvalue", 
         showCategory = 5, 
         foldChange=OE_foldchanges, 
         vertex.label.font=6)
```


If you are interested in significant processes that are not among the top five, you can subset your ego dataset to only display these processes:
```{r}
## Subsetting the ego results without overwriting original `ego` variable
ego2 <- ego

ego2@result <- ego@result[c(1,3,4,8,9),]

## Plotting terms of interest
cnetplot(ego2, 
         categorySize="pvalue", 
         foldChange=OE_foldchanges, 
         showCategory = 5, 
         vertex.label.font=6)
```

## Gene set enrichment analysis (GSEA)

GSEA uses the entire list of log2 fold changes from all genes. It is based on looking for enrichment of genesets among the large positive or negative fold changes. Thus, rather than setting an arbitrary threshold to identify ‘significant genes’, all genes are considered in the analysis. The gene-level statistics from the dataset are aggregated to generate a single pathway-level statistic and statistical significance of each pathway is reported. 

To perform GSEA analysis of gene sets, clusterProfiler requires the genes to be identified using Entrez IDs for all genes in our results dataset. We also need to remove the NA values and duplicates (due to gene ID conversion) prior to the analysis:

```{r}
## Remove any NA values
m = match(res_ids$ensgene,ids$ensgene)
res_ids$entrez = ids$entrez[m]


wna = which(is.na(res_ids$entrez))
res_entrez = res_ids[-wna,]
wdup = which(!duplicated(res_entrez$entrez))
res_entrez=res_entrez[wdup,]

```

Finally, extract and name the fold changes:
```{r}
## Extract the foldchanges
foldchanges <- res_entrez$log2FoldChange

## Name each fold change with the corresponding Entrez ID
names(foldchanges) <- res_entrez$entrez
```

Next we need to order the fold changes in decreasing order. To do this we'll use the `sort()` function, which takes a vector as input. This is in contrast to Tidyverse's `arrange()`, which requires a data frame.
```{r}
## Sort fold changes in decreasing order
foldchanges <- sort(foldchanges, decreasing = TRUE)

head(foldchanges)
```

We can explore the enrichment of BP Gene Ontology terms using gene set enrichment analysis: 
```{r}
# GSEA using gene sets associated with BP Gene Ontology terms
gseaGO <- gseGO(geneList = foldchanges, 
              OrgDb = org.Hs.eg.db, 
              ont = 'BP', 
              nPerm = 1000, 
              minGSSize = 20, 
              pvalueCutoff = 0.05,
              verbose = FALSE) 

gseaGO_results <- gseaGO@result

gseaplot(gseaGO, geneSetID = 'GO:0007423')
```

There are other gene sets available for GSEA analysis in clusterProfiler (Disease Ontology, Reactome pathways, etc.). In addition, it is possible to supply your own gene set GMT file, such as a GMT for MSigDB using special clusterProfiler functions as shown below:
```{r}

library(GSEABase)

# Load in GMT file of gene sets (we downloaded from the Broad Institute [website](http://software.broadinstitute.org/gsea/msigdb/collections.jsp) for MSigDB)

c2 <- read.gmt("data/c2.all.v2023.1.Hs.entrez.gmt")

msig <- GSEA(foldchanges, TERM2GENE=c2, verbose=FALSE)

msig_df <- data.frame(msig)
```




